<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>raffiot.io API documentation</title>
<meta name="description" content="Data structure representing a computation." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>raffiot.io</code></h1>
</header>
<section id="section-intro">
<p>Data structure representing a computation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Data structure representing a computation.
&#34;&#34;&#34;

from __future__ import annotations
from typing import TypeVar, Generic, Callable, Any
from typing_extensions import final
from dataclasses import dataclass
from raffiot import result, _MatchError
from raffiot.result import Result

R = TypeVar(&#34;R&#34;)
E = TypeVar(&#34;E&#34;)
A = TypeVar(&#34;A&#34;)
X = TypeVar(&#34;X&#34;)
R2 = TypeVar(&#34;R2&#34;)
E2 = TypeVar(&#34;E2&#34;)
A2 = TypeVar(&#34;A2&#34;)


class IO(Generic[R, E, A]):
    &#34;&#34;&#34;
    Represent a computation that computes a value of type A,
    may fail with an error (expected failure) of type E and have access
    anytime to a read-only context of type R.

    /!\\ VERY IMPORTANT /!\\
        1. The IO is LAZY:
            no code is run until you invoke the run method.
        2. The IO never raises exceptions (unless there is a bug):
            it returns panics instead.
        3. The IO is stack-safe, but you need to make sure your own code is too!
            use defer and defer_io to avoid stack-overflow.

    Have a look to the documentation and examples to learn how to use it.
    &#34;&#34;&#34;

    @final
    def __init__(self, tag, fields):
        self.tag = tag
        self.fields = fields

    @final
    def map(self, f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Transform the computed value with f if the computation is successful.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return map(self, f)

    @final
    def flat_map(self, f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) can be used in the second (f).
        &#34;&#34;&#34;
        return flat_map(self, f)

    @final
    def then(self, io: IO[R, E, A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) is dropped.
        &#34;&#34;&#34;
        return self.flat_map(lambda _: io)

    @final
    def ap(self: IO[R, E, Callable[[X], A]], arg: IO[R, E, X]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Noting functions from X to A: X -&gt; A

        If self computes a function f: X -&gt; A
        and arg computes a value x: X
        then self.ap(arg) computes f(x): A
        &#34;&#34;&#34;
        return ap(self, arg)

    @final
    def flatten(self):
        &#34;&#34;&#34;
        Concatenation function on IO
        &#34;&#34;&#34;
        return flatten(self)

    # Reader API

    @final
    def contra_map_read(self, f: Callable[[R2], R]) -&gt; IO[R2, E, A]:
        &#34;&#34;&#34;
        Transform the context with f.
        Note that f is not from R to R2 but from R2 to R!
        &#34;&#34;&#34;
        return contra_map_read(f, self)

    # Error API

    @final
    def catch(self, handler: Callable[[E], IO[R, E, A]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to errors (the except part of a try-except).

        On error, call the handler with the error.
        &#34;&#34;&#34;
        return catch(self, handler)

    @final
    def map_error(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
        &#34;&#34;&#34;
        Transform the stored error if the computation fails on an error.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return map_error(self, f)

    # Panic

    @final
    def recover(self, handler: Callable[[Exception], IO[R, E, A]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to panics (the except part of a try-except).

        On panic, call the handler with the exception.
        &#34;&#34;&#34;
        return recover(self, handler)

    @final
    def map_panic(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
        &#34;&#34;&#34;
        Transform the exception stored if the computation fails on a panic.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return map_panic(self, f)

    @final
    def run(self, context: R) -&gt; Result[E, A]:
        &#34;&#34;&#34;
        Run the computation.

        Note that a IO is a data structure, no action is performed until you
        call run. You may view an IO value as a function declaration.
        Declaring a function does not execute its body. Only calling the
        function does. Likewise, declaring an IO does not execute its content,
        only running the IO does.

        Note that the return value is a Result[E,A].
        No exception will be raised by run (unless there is a bug), run will
        returns a panic instead!
        &#34;&#34;&#34;
        return run(context, self)

    @final
    def attempt(self) -&gt; IO[R, E, Result[E, A]]:
        &#34;&#34;&#34;
        Transform this computation that may fail into a computation
        that never fails but returns a Result[E,A].

        - If self successfully computes a, then self.attempt() successfully computes Ok(a).
        - If self fails on error e, then self.attempt() successfully computes Error(e).
        - If self fails on panic p, then self.attempt() successfully computes Panic(p).

        Note that errors and panics stop the computation, unless a catch or
        recover reacts to such failures. But using map, flat_map, flatten and
        ap is sometimes easier than using catch and recover. attempt transforms
        a failed computation into a successful computation returning a failure,
        thus enabling you to use map, flat_map, ... to deal with errors.
        &#34;&#34;&#34;
        return (
            self.map(result.pure)
            .catch(lambda x: pure(result.error(x)))
            .recover(lambda x: pure(result.panic(x)))
        )

    @final
    def finally_(self, io: IO[R, Any, Any]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        After having computed self, but before returning its result,
        execute the io computation.

        This is extremely useful when you need to perform an action,
        unconditionally, at the end of a computation, without changing
        its result, like releasing a resource.
        &#34;&#34;&#34;
        return self.attempt().flat_map(lambda r: io.attempt().then(from_result(r)))

    @final
    def on_failure(
        self, handler: Callable[[Result[E, Any]], IO[R, E, A]]
    ) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Combined form of catch and recover.
        React to any failure of the computation.
        Do nothing if the computation is successful.

        - The handler will be called on Error(e) if the computation fails with error e.
        - The handler will be called on Panic(p) if the computation fails with panic p.
        - The handler will never be called on Ok(a).
        &#34;&#34;&#34;
        return self.attempt().flat_map(
            lambda r: r.fold(
                pure,
                lambda e: handler(result.error(e)),
                lambda p: handler(result.panic(p)),
            )
        )


# IO PURE             0 VALUE
# IO AP               1 FUN       ARG
# IO FLATTEN          2 TOWER
# IO DEFER            3 DEFERED
# IO READ             4
# IO CONTRA_MAP_READ  5 FUN       MAIN
# IO RAISE            6 ERROR
# IO CATCH            7 MAIN      HANDLER
# IO MAP_ERROR        8 MAIN      FUN
# IO PANIC            9 EXCEPTION
# IO RECOVER         10 MAIN      HANDLER
# IO MAP_PANIC       11 MAIN      FUN


def pure(a: A) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    An always successful computation returning a.
    &#34;&#34;&#34;
    return IO(0, a)


def ap(fun: IO[R, E, Callable[[X], A]], arg: IO[R, E, X]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Noting functions from X to A: X -&gt; A

    If fun computes a function f: X -&gt; A
    and arg computes a value x: X
    then fun.ap(arg) computes f(x): A
    &#34;&#34;&#34;
    if fun.tag == 0 and arg.tag == 0:
        return IO(3, lambda: fun.fields(arg.fields))
    return IO(1, (fun, arg))


def map(main: IO[R, E, A], f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Transform the computed value with f if the computation is successful.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return IO(1, (IO(0, f), main))


def flatten(tower: IO[R, E, IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Concatenation function on IO
    &#34;&#34;&#34;
    if tower.tag == 0:
        return tower.fields
    return IO(2, tower)


def flat_map(main: IO[R, E, A], f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Chain two computations.
    The result of the first one (main) can be used in the second (f).
    &#34;&#34;&#34;
    if main.tag == 0:
        IO(2, IO(3, lambda: f(main.fields)))
    return IO(2, IO(1, (IO(0, f), main)))


def defer(deferred: Callable[[], A]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Defer a computation.

    The result of the computation is the result of deferred() but
    this call is deferred until the IO is run.

    /!\\ VERY IMPORTANT /!\\
    This is the only valid way to execute side effects.
    All side effect should we wrapped by:
        defer(lambda: &lt;your side effecting code&gt;)

    For example, the following code is buggy:
        &gt;&gt;&gt; hello: IO[None, None, None] = pure(print(&#34;Hello World!&#34;))
        &#34;Hello World!&#34; is printed
        &gt;&gt;&gt; hello.run(None)
        Nothing printed
    The correct version is:
        &gt;&gt;&gt; hello: IO[None, None, None] = defer(lambda: print(&#34;Hello World!&#34;))
        Nothing is printed
        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed
        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed again
    &#34;&#34;&#34;
    return IO(3, deferred)


def defer_io(deferred: Callable[[], IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Make a function that returns an IO, an IO itself.

    This is extremely useful with recursive function that would normally blow
    the stack (raise a stack overflow exception). Deferring recursive calls
    eliminates stack overflow.

    For example, the following code blow the stack:
        &gt;&gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;&gt;    return f()
        &gt;&gt;&gt; f().run(None)
        RecursionError: maximum recursion depth exceeded
    But, this one runs forever:
        &gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;    return defer_io(lambda: f())
        &gt;&gt; f().run(None)
    &#34;&#34;&#34;
    return IO(2, IO(3, deferred))


def read() -&gt; IO[R, E, R]:
    &#34;&#34;&#34;
    Read the context.

    To execute a computation IO[R,E,A], you need to call the run method with
    some value r of type R: io.run(r). the read() action returns the value r
    given to run.

    Please note that the contra_map_read method can transform this value r.
    &#34;&#34;&#34;
    return IO(4, None)


def contra_map_read(fun: Callable[[R], R2], main: IO[R2, E, A]) -&gt; IO[R, E2, A]:
    &#34;&#34;&#34;
    Transform the context with f.
    Note that f is not from R to R2 but from R2 to R!
    &#34;&#34;&#34;
    if main.tag in [0, 3, 6, 9]:
        return main
    return IO(5, (fun, main))


def error(err: E) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails on the error err.
    &#34;&#34;&#34;
    return IO(6, err)


def catch(main: IO[R, E, A], handler: Callable[[E], IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34; &#34;
    React to errors (the except part of a try-except).

    On error, call the handler with the error.
    &#34;&#34;&#34;
    if main.tag in [0, 3, 4, 9]:
        return main
    return IO(7, (main, handler))


def map_error(main: IO[R, E2, A], fun: Callable[[E2], E]) -&gt; IO[R, E2, A]:
    &#34;&#34;&#34;
    Transform the stored error if the computation fails on an error.
    Do nothing otherwise.
    &#34;&#34;&#34;
    if main.tag in [0, 3, 4, 9]:
        return main
    return IO(8, (main, fun))


def panic(exception: Exception) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails with the panic exception.
    &#34;&#34;&#34;
    return IO(9, exception)


def recover(
    main: IO[R, E, A], handler: Callable[[Exception], IO[R, E, A]]
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    React to panics (the except part of a try-except).

    On panic, call the handler with the exception.
    &#34;&#34;&#34;
    if main.tag in [0, 4, 6]:
        return main
    return IO(10, (main, handler))


def map_panic(main: IO[R, E, A], fun: Callable[[Exception], Exception]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Transform the exception stored if the computation fails on a panic.
    Do nothing otherwise.
    &#34;&#34;&#34;
    if main.tag in [0, 4, 6]:
        return main
    return IO(11, (main, fun))


def from_result(r: Result[E, A]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that:
    - success if r is an Ok
    - fails with error e if r is Error(e)
    - fails with panic p if r is Panic(p)
    &#34;&#34;&#34;
    return r.fold(pure, error, panic)


def run(main_context: R, main_io: IO[R, E, A]) -&gt; Result[E, A]:
    &#34;&#34;&#34;
    Run the IO main_io with main_context as the context (the value that read()
    returns).

    It never raise any exception (unless there is a bug) so do not
    treat the absence of exception as a success. Instead process the
    returned Result[E,A].
    &#34;&#34;&#34;
    context = main_context
    io = main_io
    cont = (0,)
    arg = None
    # CONT ID        0
    # CONT AP1       1 CONT CONTEXT IO
    # CONT AP2       2 CONT FUN
    # CONT FLATTEN   3 CONT CONTEXT
    # CONT CATCH     4 CONT CONTEXT HANDLER
    # CONT MAP_ERROR 5 CONT FUN
    # CONT RECOVER   6 CONT CONTEXT HANDLER
    # CONT MAP_PANIC 7 CONT FUN

    while True:
        # Eval IO
        while True:
            tag = io.tag
            if tag == 0:  # PURE
                arg = result.Ok(io.fields)
                break
            if tag == 1:  # AP
                cont = (1, cont, context, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 2:  # FLATTEN
                cont = (3, cont, context)
                io = io.fields
                continue
            if tag == 3:  # DEREF
                try:
                    arg = result.Ok(io.fields())
                except Exception as exception:
                    arg = result.Panic(exception)
                break
            if tag == 4:  # READ
                arg = result.Ok(context)
                break
            if tag == 5:  # MAP READ
                try:
                    context = io.fields[0](context)
                    io = io.fields[1]
                    continue
                except Exception as exception:
                    arg = result.Panic(exception)
                    break
            if tag == 6:  # RAISE
                arg = result.Error(io.fields)
                break
            if tag == 7:  # CATCH
                cont = (4, cont, context, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 8:  # MAP ERROR
                cont = (5, cont, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 9:  # PANIC
                arg = result.Panic(io.fields)
                break
            if tag == 10:  # RECOVER
                cont = (6, cont, context, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 11:  # MAP PANIC
                cont = (7, cont, io.fields[1])
                io = io.fields[0]
                continue
            arg = result.Panic(_MatchError(f&#34;{io} should be an IO&#34;))
            break

        # Eval Cont
        while True:
            tag = cont[0]
            if tag == 0:  # Cont ID
                return arg
            if tag == 1:  # Cont AP1
                context = cont[2]
                io = cont[3]
                cont = (2, cont[1], arg)
                break
            if tag == 2:  # Cont AP2
                try:
                    arg = cont[2].ap(arg)
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 3:  # Cont Flatten
                if isinstance(arg, result.Ok):
                    context = cont[2]
                    io = arg.success
                    cont = cont[1]
                    break
                cont = cont[1]
                continue
            if tag == 4:  # Cont CATCH
                try:
                    if isinstance(arg, result.Error):
                        io = cont[3](arg.error)
                        context = cont[2]
                        cont = cont[1]
                        break
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 5:  # Cont MAP ERROR
                try:
                    arg = arg.map_error(cont[2])
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 6:  # Cont RECOVER
                try:
                    if isinstance(arg, result.Panic):
                        io = cont[3](arg.exception)
                        context = cont[2]
                        cont = cont[1]
                        break
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 7:  # CONT MAP PANIC
                try:
                    arg = arg.map_panic(cont[2])
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            raise _MatchError(f&#34;{cont} should be a Cont&#34;)


def safe(f: Callable[..., IO[R, E, A]]) -&gt; Callable[..., IO[R, E, A]]:
    &#34;&#34;&#34;
    Ensures a function retuning an IO never raise any exception but returns a
    panic instead.
    &#34;&#34;&#34;

    def wrapper(*args, **kwargs):
        return pure(f).flat_map(lambda g: g(*args, **kwargs))

    return wrapper</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="raffiot.io.ap"><code class="name flex">
<span>def <span class="ident">ap</span></span>(<span>fun: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, Callable[[X], A]], arg: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, X]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Noting functions from X to A: X -&gt; A</p>
<p>If fun computes a function f: X -&gt; A
and arg computes a value x: X
then fun.ap(arg) computes f(x): A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ap(fun: IO[R, E, Callable[[X], A]], arg: IO[R, E, X]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Noting functions from X to A: X -&gt; A

    If fun computes a function f: X -&gt; A
    and arg computes a value x: X
    then fun.ap(arg) computes f(x): A
    &#34;&#34;&#34;
    if fun.tag == 0 and arg.tag == 0:
        return IO(3, lambda: fun.fields(arg.fields))
    return IO(1, (fun, arg))</code></pre>
</details>
</dd>
<dt id="raffiot.io.catch"><code class="name flex">
<span>def <span class="ident">catch</span></span>(<span>main: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], handler: Callable[[E], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>"
React to errors (the except part of a try-except).</p>
<p>On error, call the handler with the error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def catch(main: IO[R, E, A], handler: Callable[[E], IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34; &#34;
    React to errors (the except part of a try-except).

    On error, call the handler with the error.
    &#34;&#34;&#34;
    if main.tag in [0, 3, 4, 9]:
        return main
    return IO(7, (main, handler))</code></pre>
</details>
</dd>
<dt id="raffiot.io.contra_map_read"><code class="name flex">
<span>def <span class="ident">contra_map_read</span></span>(<span>fun: Callable[[R], R2], main: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R2, E, A]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E2, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the context with f.
Note that f is not from R to R2 but from R2 to R!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contra_map_read(fun: Callable[[R], R2], main: IO[R2, E, A]) -&gt; IO[R, E2, A]:
    &#34;&#34;&#34;
    Transform the context with f.
    Note that f is not from R to R2 but from R2 to R!
    &#34;&#34;&#34;
    if main.tag in [0, 3, 6, 9]:
        return main
    return IO(5, (fun, main))</code></pre>
</details>
</dd>
<dt id="raffiot.io.defer"><code class="name flex">
<span>def <span class="ident">defer</span></span>(<span>deferred: Callable[[], A]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Defer a computation.</p>
<p>The result of the computation is the result of deferred() but
this call is deferred until the IO is run.</p>
<p>/!\ VERY IMPORTANT /!\
This is the only valid way to execute side effects.
All side effect should we wrapped by:
defer(lambda: <your side effecting code>)</p>
<p>For example, the following code is buggy:
&gt;&gt;&gt; hello: IO[None, None, None] = pure(print("Hello World!"))
"Hello World!" is printed
&gt;&gt;&gt; hello.run(None)
Nothing printed
The correct version is:
&gt;&gt;&gt; hello: IO[None, None, None] = defer(lambda: print("Hello World!"))
Nothing is printed
&gt;&gt;&gt; hello.run(None)
"Hello World!" is printed
&gt;&gt;&gt; hello.run(None)
"Hello World!" is printed again</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defer(deferred: Callable[[], A]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Defer a computation.

    The result of the computation is the result of deferred() but
    this call is deferred until the IO is run.

    /!\\ VERY IMPORTANT /!\\
    This is the only valid way to execute side effects.
    All side effect should we wrapped by:
        defer(lambda: &lt;your side effecting code&gt;)

    For example, the following code is buggy:
        &gt;&gt;&gt; hello: IO[None, None, None] = pure(print(&#34;Hello World!&#34;))
        &#34;Hello World!&#34; is printed
        &gt;&gt;&gt; hello.run(None)
        Nothing printed
    The correct version is:
        &gt;&gt;&gt; hello: IO[None, None, None] = defer(lambda: print(&#34;Hello World!&#34;))
        Nothing is printed
        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed
        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed again
    &#34;&#34;&#34;
    return IO(3, deferred)</code></pre>
</details>
</dd>
<dt id="raffiot.io.defer_io"><code class="name flex">
<span>def <span class="ident">defer_io</span></span>(<span>deferred: Callable[[], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a function that returns an IO, an IO itself.</p>
<p>This is extremely useful with recursive function that would normally blow
the stack (raise a stack overflow exception). Deferring recursive calls
eliminates stack overflow.</p>
<p>For example, the following code blow the stack:
&gt;&gt;&gt; def f() -&gt; IO[None,None,None]:
&gt;&gt;&gt;
return f()
&gt;&gt;&gt; f().run(None)
RecursionError: maximum recursion depth exceeded
But, this one runs forever:
&gt;&gt; def f() -&gt; IO[None,None,None]:
&gt;&gt;
return defer_io(lambda: f())
&gt;&gt; f().run(None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defer_io(deferred: Callable[[], IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Make a function that returns an IO, an IO itself.

    This is extremely useful with recursive function that would normally blow
    the stack (raise a stack overflow exception). Deferring recursive calls
    eliminates stack overflow.

    For example, the following code blow the stack:
        &gt;&gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;&gt;    return f()
        &gt;&gt;&gt; f().run(None)
        RecursionError: maximum recursion depth exceeded
    But, this one runs forever:
        &gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;    return defer_io(lambda: f())
        &gt;&gt; f().run(None)
    &#34;&#34;&#34;
    return IO(2, IO(3, deferred))</code></pre>
</details>
</dd>
<dt id="raffiot.io.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>err: E) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Computation that fails on the error err.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(err: E) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails on the error err.
    &#34;&#34;&#34;
    return IO(6, err)</code></pre>
</details>
</dd>
<dt id="raffiot.io.flat_map"><code class="name flex">
<span>def <span class="ident">flat_map</span></span>(<span>main: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], f: Callable[[A], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A2]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Chain two computations.
The result of the first one (main) can be used in the second (f).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flat_map(main: IO[R, E, A], f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Chain two computations.
    The result of the first one (main) can be used in the second (f).
    &#34;&#34;&#34;
    if main.tag == 0:
        IO(2, IO(3, lambda: f(main.fields)))
    return IO(2, IO(1, (IO(0, f), main)))</code></pre>
</details>
</dd>
<dt id="raffiot.io.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>tower: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenation function on IO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(tower: IO[R, E, IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Concatenation function on IO
    &#34;&#34;&#34;
    if tower.tag == 0:
        return tower.fields
    return IO(2, tower)</code></pre>
</details>
</dd>
<dt id="raffiot.io.from_result"><code class="name flex">
<span>def <span class="ident">from_result</span></span>(<span>r: Result[E, A]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Computation that:
- success if r is an Ok
- fails with error e if r is Error(e)
- fails with panic p if r is Panic(p)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_result(r: Result[E, A]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that:
    - success if r is an Ok
    - fails with error e if r is Error(e)
    - fails with panic p if r is Panic(p)
    &#34;&#34;&#34;
    return r.fold(pure, error, panic)</code></pre>
</details>
</dd>
<dt id="raffiot.io.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>main: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], f: Callable[[A], A2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the computed value with f if the computation is successful.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(main: IO[R, E, A], f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Transform the computed value with f if the computation is successful.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return IO(1, (IO(0, f), main))</code></pre>
</details>
</dd>
<dt id="raffiot.io.map_error"><code class="name flex">
<span>def <span class="ident">map_error</span></span>(<span>main: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E2, A], fun: Callable[[E2], E]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E2, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the stored error if the computation fails on an error.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_error(main: IO[R, E2, A], fun: Callable[[E2], E]) -&gt; IO[R, E2, A]:
    &#34;&#34;&#34;
    Transform the stored error if the computation fails on an error.
    Do nothing otherwise.
    &#34;&#34;&#34;
    if main.tag in [0, 3, 4, 9]:
        return main
    return IO(8, (main, fun))</code></pre>
</details>
</dd>
<dt id="raffiot.io.map_panic"><code class="name flex">
<span>def <span class="ident">map_panic</span></span>(<span>main: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], fun: Callable[[Exception], Exception]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the exception stored if the computation fails on a panic.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_panic(main: IO[R, E, A], fun: Callable[[Exception], Exception]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Transform the exception stored if the computation fails on a panic.
    Do nothing otherwise.
    &#34;&#34;&#34;
    if main.tag in [0, 4, 6]:
        return main
    return IO(11, (main, fun))</code></pre>
</details>
</dd>
<dt id="raffiot.io.panic"><code class="name flex">
<span>def <span class="ident">panic</span></span>(<span>exception: Exception) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Computation that fails with the panic exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panic(exception: Exception) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails with the panic exception.
    &#34;&#34;&#34;
    return IO(9, exception)</code></pre>
</details>
</dd>
<dt id="raffiot.io.pure"><code class="name flex">
<span>def <span class="ident">pure</span></span>(<span>a: A) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>An always successful computation returning a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pure(a: A) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    An always successful computation returning a.
    &#34;&#34;&#34;
    return IO(0, a)</code></pre>
</details>
</dd>
<dt id="raffiot.io.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~R]</span>
</code></dt>
<dd>
<div class="desc"><p>Read the context.</p>
<p>To execute a computation IO[R,E,A], you need to call the run method with
some value r of type R: io.run(r). the read() action returns the value r
given to run.</p>
<p>Please note that the contra_map_read method can transform this value r.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read() -&gt; IO[R, E, R]:
    &#34;&#34;&#34;
    Read the context.

    To execute a computation IO[R,E,A], you need to call the run method with
    some value r of type R: io.run(r). the read() action returns the value r
    given to run.

    Please note that the contra_map_read method can transform this value r.
    &#34;&#34;&#34;
    return IO(4, None)</code></pre>
</details>
</dd>
<dt id="raffiot.io.recover"><code class="name flex">
<span>def <span class="ident">recover</span></span>(<span>main: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], handler: Callable[[Exception], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>React to panics (the except part of a try-except).</p>
<p>On panic, call the handler with the exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recover(
    main: IO[R, E, A], handler: Callable[[Exception], IO[R, E, A]]
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    React to panics (the except part of a try-except).

    On panic, call the handler with the exception.
    &#34;&#34;&#34;
    if main.tag in [0, 4, 6]:
        return main
    return IO(10, (main, handler))</code></pre>
</details>
</dd>
<dt id="raffiot.io.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>main_context: R, main_io: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]) ‑> <a title="raffiot.result.Result" href="result.html#raffiot.result.Result">Result</a>[~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Run the IO main_io with main_context as the context (the value that read()
returns).</p>
<p>It never raise any exception (unless there is a bug) so do not
treat the absence of exception as a success. Instead process the
returned Result[E,A].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(main_context: R, main_io: IO[R, E, A]) -&gt; Result[E, A]:
    &#34;&#34;&#34;
    Run the IO main_io with main_context as the context (the value that read()
    returns).

    It never raise any exception (unless there is a bug) so do not
    treat the absence of exception as a success. Instead process the
    returned Result[E,A].
    &#34;&#34;&#34;
    context = main_context
    io = main_io
    cont = (0,)
    arg = None
    # CONT ID        0
    # CONT AP1       1 CONT CONTEXT IO
    # CONT AP2       2 CONT FUN
    # CONT FLATTEN   3 CONT CONTEXT
    # CONT CATCH     4 CONT CONTEXT HANDLER
    # CONT MAP_ERROR 5 CONT FUN
    # CONT RECOVER   6 CONT CONTEXT HANDLER
    # CONT MAP_PANIC 7 CONT FUN

    while True:
        # Eval IO
        while True:
            tag = io.tag
            if tag == 0:  # PURE
                arg = result.Ok(io.fields)
                break
            if tag == 1:  # AP
                cont = (1, cont, context, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 2:  # FLATTEN
                cont = (3, cont, context)
                io = io.fields
                continue
            if tag == 3:  # DEREF
                try:
                    arg = result.Ok(io.fields())
                except Exception as exception:
                    arg = result.Panic(exception)
                break
            if tag == 4:  # READ
                arg = result.Ok(context)
                break
            if tag == 5:  # MAP READ
                try:
                    context = io.fields[0](context)
                    io = io.fields[1]
                    continue
                except Exception as exception:
                    arg = result.Panic(exception)
                    break
            if tag == 6:  # RAISE
                arg = result.Error(io.fields)
                break
            if tag == 7:  # CATCH
                cont = (4, cont, context, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 8:  # MAP ERROR
                cont = (5, cont, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 9:  # PANIC
                arg = result.Panic(io.fields)
                break
            if tag == 10:  # RECOVER
                cont = (6, cont, context, io.fields[1])
                io = io.fields[0]
                continue
            if tag == 11:  # MAP PANIC
                cont = (7, cont, io.fields[1])
                io = io.fields[0]
                continue
            arg = result.Panic(_MatchError(f&#34;{io} should be an IO&#34;))
            break

        # Eval Cont
        while True:
            tag = cont[0]
            if tag == 0:  # Cont ID
                return arg
            if tag == 1:  # Cont AP1
                context = cont[2]
                io = cont[3]
                cont = (2, cont[1], arg)
                break
            if tag == 2:  # Cont AP2
                try:
                    arg = cont[2].ap(arg)
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 3:  # Cont Flatten
                if isinstance(arg, result.Ok):
                    context = cont[2]
                    io = arg.success
                    cont = cont[1]
                    break
                cont = cont[1]
                continue
            if tag == 4:  # Cont CATCH
                try:
                    if isinstance(arg, result.Error):
                        io = cont[3](arg.error)
                        context = cont[2]
                        cont = cont[1]
                        break
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 5:  # Cont MAP ERROR
                try:
                    arg = arg.map_error(cont[2])
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 6:  # Cont RECOVER
                try:
                    if isinstance(arg, result.Panic):
                        io = cont[3](arg.exception)
                        context = cont[2]
                        cont = cont[1]
                        break
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            if tag == 7:  # CONT MAP PANIC
                try:
                    arg = arg.map_panic(cont[2])
                except Exception as exception:
                    arg = result.Panic(exception)
                cont = cont[1]
                continue
            raise _MatchError(f&#34;{cont} should be a Cont&#34;)</code></pre>
</details>
</dd>
<dt id="raffiot.io.safe"><code class="name flex">
<span>def <span class="ident">safe</span></span>(<span>f: Callable[..., <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> Callable[..., <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures a function retuning an IO never raise any exception but returns a
panic instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe(f: Callable[..., IO[R, E, A]]) -&gt; Callable[..., IO[R, E, A]]:
    &#34;&#34;&#34;
    Ensures a function retuning an IO never raise any exception but returns a
    panic instead.
    &#34;&#34;&#34;

    def wrapper(*args, **kwargs):
        return pure(f).flat_map(lambda g: g(*args, **kwargs))

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="raffiot.io.IO"><code class="flex name class">
<span>class <span class="ident">IO</span></span>
<span>(</span><span>tag, fields)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a computation that computes a value of type A,
may fail with an error (expected failure) of type E and have access
anytime to a read-only context of type R.</p>
<p>/!\ VERY IMPORTANT /!\
1. The IO is LAZY:
no code is run until you invoke the run method.
2. The IO never raises exceptions (unless there is a bug):
it returns panics instead.
3. The IO is stack-safe, but you need to make sure your own code is too!
use defer and defer_io to avoid stack-overflow.</p>
<p>Have a look to the documentation and examples to learn how to use it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IO(Generic[R, E, A]):
    &#34;&#34;&#34;
    Represent a computation that computes a value of type A,
    may fail with an error (expected failure) of type E and have access
    anytime to a read-only context of type R.

    /!\\ VERY IMPORTANT /!\\
        1. The IO is LAZY:
            no code is run until you invoke the run method.
        2. The IO never raises exceptions (unless there is a bug):
            it returns panics instead.
        3. The IO is stack-safe, but you need to make sure your own code is too!
            use defer and defer_io to avoid stack-overflow.

    Have a look to the documentation and examples to learn how to use it.
    &#34;&#34;&#34;

    @final
    def __init__(self, tag, fields):
        self.tag = tag
        self.fields = fields

    @final
    def map(self, f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Transform the computed value with f if the computation is successful.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return map(self, f)

    @final
    def flat_map(self, f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) can be used in the second (f).
        &#34;&#34;&#34;
        return flat_map(self, f)

    @final
    def then(self, io: IO[R, E, A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) is dropped.
        &#34;&#34;&#34;
        return self.flat_map(lambda _: io)

    @final
    def ap(self: IO[R, E, Callable[[X], A]], arg: IO[R, E, X]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Noting functions from X to A: X -&gt; A

        If self computes a function f: X -&gt; A
        and arg computes a value x: X
        then self.ap(arg) computes f(x): A
        &#34;&#34;&#34;
        return ap(self, arg)

    @final
    def flatten(self):
        &#34;&#34;&#34;
        Concatenation function on IO
        &#34;&#34;&#34;
        return flatten(self)

    # Reader API

    @final
    def contra_map_read(self, f: Callable[[R2], R]) -&gt; IO[R2, E, A]:
        &#34;&#34;&#34;
        Transform the context with f.
        Note that f is not from R to R2 but from R2 to R!
        &#34;&#34;&#34;
        return contra_map_read(f, self)

    # Error API

    @final
    def catch(self, handler: Callable[[E], IO[R, E, A]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to errors (the except part of a try-except).

        On error, call the handler with the error.
        &#34;&#34;&#34;
        return catch(self, handler)

    @final
    def map_error(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
        &#34;&#34;&#34;
        Transform the stored error if the computation fails on an error.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return map_error(self, f)

    # Panic

    @final
    def recover(self, handler: Callable[[Exception], IO[R, E, A]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to panics (the except part of a try-except).

        On panic, call the handler with the exception.
        &#34;&#34;&#34;
        return recover(self, handler)

    @final
    def map_panic(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
        &#34;&#34;&#34;
        Transform the exception stored if the computation fails on a panic.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return map_panic(self, f)

    @final
    def run(self, context: R) -&gt; Result[E, A]:
        &#34;&#34;&#34;
        Run the computation.

        Note that a IO is a data structure, no action is performed until you
        call run. You may view an IO value as a function declaration.
        Declaring a function does not execute its body. Only calling the
        function does. Likewise, declaring an IO does not execute its content,
        only running the IO does.

        Note that the return value is a Result[E,A].
        No exception will be raised by run (unless there is a bug), run will
        returns a panic instead!
        &#34;&#34;&#34;
        return run(context, self)

    @final
    def attempt(self) -&gt; IO[R, E, Result[E, A]]:
        &#34;&#34;&#34;
        Transform this computation that may fail into a computation
        that never fails but returns a Result[E,A].

        - If self successfully computes a, then self.attempt() successfully computes Ok(a).
        - If self fails on error e, then self.attempt() successfully computes Error(e).
        - If self fails on panic p, then self.attempt() successfully computes Panic(p).

        Note that errors and panics stop the computation, unless a catch or
        recover reacts to such failures. But using map, flat_map, flatten and
        ap is sometimes easier than using catch and recover. attempt transforms
        a failed computation into a successful computation returning a failure,
        thus enabling you to use map, flat_map, ... to deal with errors.
        &#34;&#34;&#34;
        return (
            self.map(result.pure)
            .catch(lambda x: pure(result.error(x)))
            .recover(lambda x: pure(result.panic(x)))
        )

    @final
    def finally_(self, io: IO[R, Any, Any]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        After having computed self, but before returning its result,
        execute the io computation.

        This is extremely useful when you need to perform an action,
        unconditionally, at the end of a computation, without changing
        its result, like releasing a resource.
        &#34;&#34;&#34;
        return self.attempt().flat_map(lambda r: io.attempt().then(from_result(r)))

    @final
    def on_failure(
        self, handler: Callable[[Result[E, Any]], IO[R, E, A]]
    ) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Combined form of catch and recover.
        React to any failure of the computation.
        Do nothing if the computation is successful.

        - The handler will be called on Error(e) if the computation fails with error e.
        - The handler will be called on Panic(p) if the computation fails with panic p.
        - The handler will never be called on Ok(a).
        &#34;&#34;&#34;
        return self.attempt().flat_map(
            lambda r: r.fold(
                pure,
                lambda e: handler(result.error(e)),
                lambda p: handler(result.panic(p)),
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="raffiot.io.IO.ap"><code class="name flex">
<span>def <span class="ident">ap</span></span>(<span>self: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, Callable[[X], A]], arg: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, X]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Noting functions from X to A: X -&gt; A</p>
<p>If self computes a function f: X -&gt; A
and arg computes a value x: X
then self.ap(arg) computes f(x): A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def ap(self: IO[R, E, Callable[[X], A]], arg: IO[R, E, X]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Noting functions from X to A: X -&gt; A

    If self computes a function f: X -&gt; A
    and arg computes a value x: X
    then self.ap(arg) computes f(x): A
    &#34;&#34;&#34;
    return ap(self, arg)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.attempt"><code class="name flex">
<span>def <span class="ident">attempt</span></span>(<span>self) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, <a title="raffiot.result.Result" href="result.html#raffiot.result.Result">Result</a>[~E, ~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform this computation that may fail into a computation
that never fails but returns a Result[E,A].</p>
<ul>
<li>If self successfully computes a, then self.attempt() successfully computes Ok(a).</li>
<li>If self fails on error e, then self.attempt() successfully computes Error(e).</li>
<li>If self fails on panic p, then self.attempt() successfully computes Panic(p).</li>
</ul>
<p>Note that errors and panics stop the computation, unless a catch or
recover reacts to such failures. But using map, flat_map, flatten and
ap is sometimes easier than using catch and recover. attempt transforms
a failed computation into a successful computation returning a failure,
thus enabling you to use map, flat_map, &hellip; to deal with errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def attempt(self) -&gt; IO[R, E, Result[E, A]]:
    &#34;&#34;&#34;
    Transform this computation that may fail into a computation
    that never fails but returns a Result[E,A].

    - If self successfully computes a, then self.attempt() successfully computes Ok(a).
    - If self fails on error e, then self.attempt() successfully computes Error(e).
    - If self fails on panic p, then self.attempt() successfully computes Panic(p).

    Note that errors and panics stop the computation, unless a catch or
    recover reacts to such failures. But using map, flat_map, flatten and
    ap is sometimes easier than using catch and recover. attempt transforms
    a failed computation into a successful computation returning a failure,
    thus enabling you to use map, flat_map, ... to deal with errors.
    &#34;&#34;&#34;
    return (
        self.map(result.pure)
        .catch(lambda x: pure(result.error(x)))
        .recover(lambda x: pure(result.panic(x)))
    )</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.catch"><code class="name flex">
<span>def <span class="ident">catch</span></span>(<span>self, handler: Callable[[E], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>React to errors (the except part of a try-except).</p>
<p>On error, call the handler with the error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def catch(self, handler: Callable[[E], IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    React to errors (the except part of a try-except).

    On error, call the handler with the error.
    &#34;&#34;&#34;
    return catch(self, handler)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.contra_map_read"><code class="name flex">
<span>def <span class="ident">contra_map_read</span></span>(<span>self, f: Callable[[R2], R]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R2, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the context with f.
Note that f is not from R to R2 but from R2 to R!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def contra_map_read(self, f: Callable[[R2], R]) -&gt; IO[R2, E, A]:
    &#34;&#34;&#34;
    Transform the context with f.
    Note that f is not from R to R2 but from R2 to R!
    &#34;&#34;&#34;
    return contra_map_read(f, self)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.finally_"><code class="name flex">
<span>def <span class="ident">finally_</span></span>(<span>self, io: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, Any, Any]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>After having computed self, but before returning its result,
execute the io computation.</p>
<p>This is extremely useful when you need to perform an action,
unconditionally, at the end of a computation, without changing
its result, like releasing a resource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def finally_(self, io: IO[R, Any, Any]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    After having computed self, but before returning its result,
    execute the io computation.

    This is extremely useful when you need to perform an action,
    unconditionally, at the end of a computation, without changing
    its result, like releasing a resource.
    &#34;&#34;&#34;
    return self.attempt().flat_map(lambda r: io.attempt().then(from_result(r)))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.flat_map"><code class="name flex">
<span>def <span class="ident">flat_map</span></span>(<span>self, f: Callable[[A], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A2]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Chain two computations.
The result of the first one (self) can be used in the second (f).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def flat_map(self, f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Chain two computations.
    The result of the first one (self) can be used in the second (f).
    &#34;&#34;&#34;
    return flat_map(self, f)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenation function on IO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def flatten(self):
    &#34;&#34;&#34;
    Concatenation function on IO
    &#34;&#34;&#34;
    return flatten(self)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f: Callable[[A], A2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the computed value with f if the computation is successful.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def map(self, f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Transform the computed value with f if the computation is successful.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return map(self, f)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.map_error"><code class="name flex">
<span>def <span class="ident">map_error</span></span>(<span>self, f: Callable[[E], E2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E2, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the stored error if the computation fails on an error.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def map_error(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
    &#34;&#34;&#34;
    Transform the stored error if the computation fails on an error.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return map_error(self, f)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.map_panic"><code class="name flex">
<span>def <span class="ident">map_panic</span></span>(<span>self, f: Callable[[E], E2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E2, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the exception stored if the computation fails on a panic.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def map_panic(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
    &#34;&#34;&#34;
    Transform the exception stored if the computation fails on a panic.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return map_panic(self, f)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.on_failure"><code class="name flex">
<span>def <span class="ident">on_failure</span></span>(<span>self, handler: Callable[[Result[E, Any]], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Combined form of catch and recover.
React to any failure of the computation.
Do nothing if the computation is successful.</p>
<ul>
<li>The handler will be called on Error(e) if the computation fails with error e.</li>
<li>The handler will be called on Panic(p) if the computation fails with panic p.</li>
<li>The handler will never be called on Ok(a).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def on_failure(
    self, handler: Callable[[Result[E, Any]], IO[R, E, A]]
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Combined form of catch and recover.
    React to any failure of the computation.
    Do nothing if the computation is successful.

    - The handler will be called on Error(e) if the computation fails with error e.
    - The handler will be called on Panic(p) if the computation fails with panic p.
    - The handler will never be called on Ok(a).
    &#34;&#34;&#34;
    return self.attempt().flat_map(
        lambda r: r.fold(
            pure,
            lambda e: handler(result.error(e)),
            lambda p: handler(result.panic(p)),
        )
    )</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.recover"><code class="name flex">
<span>def <span class="ident">recover</span></span>(<span>self, handler: Callable[[Exception], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>React to panics (the except part of a try-except).</p>
<p>On panic, call the handler with the exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def recover(self, handler: Callable[[Exception], IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    React to panics (the except part of a try-except).

    On panic, call the handler with the exception.
    &#34;&#34;&#34;
    return recover(self, handler)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, context: R) ‑> <a title="raffiot.result.Result" href="result.html#raffiot.result.Result">Result</a>[~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Run the computation.</p>
<p>Note that a IO is a data structure, no action is performed until you
call run. You may view an IO value as a function declaration.
Declaring a function does not execute its body. Only calling the
function does. Likewise, declaring an IO does not execute its content,
only running the IO does.</p>
<p>Note that the return value is a Result[E,A].
No exception will be raised by run (unless there is a bug), run will
returns a panic instead!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def run(self, context: R) -&gt; Result[E, A]:
    &#34;&#34;&#34;
    Run the computation.

    Note that a IO is a data structure, no action is performed until you
    call run. You may view an IO value as a function declaration.
    Declaring a function does not execute its body. Only calling the
    function does. Likewise, declaring an IO does not execute its content,
    only running the IO does.

    Note that the return value is a Result[E,A].
    No exception will be raised by run (unless there is a bug), run will
    returns a panic instead!
    &#34;&#34;&#34;
    return run(context, self)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.then"><code class="name flex">
<span>def <span class="ident">then</span></span>(<span>self, io: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Chain two computations.
The result of the first one (self) is dropped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
def then(self, io: IO[R, E, A2]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Chain two computations.
    The result of the first one (self) is dropped.
    &#34;&#34;&#34;
    return self.flat_map(lambda _: io)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="raffiot" href="index.html">raffiot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="raffiot.io.ap" href="#raffiot.io.ap">ap</a></code></li>
<li><code><a title="raffiot.io.catch" href="#raffiot.io.catch">catch</a></code></li>
<li><code><a title="raffiot.io.contra_map_read" href="#raffiot.io.contra_map_read">contra_map_read</a></code></li>
<li><code><a title="raffiot.io.defer" href="#raffiot.io.defer">defer</a></code></li>
<li><code><a title="raffiot.io.defer_io" href="#raffiot.io.defer_io">defer_io</a></code></li>
<li><code><a title="raffiot.io.error" href="#raffiot.io.error">error</a></code></li>
<li><code><a title="raffiot.io.flat_map" href="#raffiot.io.flat_map">flat_map</a></code></li>
<li><code><a title="raffiot.io.flatten" href="#raffiot.io.flatten">flatten</a></code></li>
<li><code><a title="raffiot.io.from_result" href="#raffiot.io.from_result">from_result</a></code></li>
<li><code><a title="raffiot.io.map" href="#raffiot.io.map">map</a></code></li>
<li><code><a title="raffiot.io.map_error" href="#raffiot.io.map_error">map_error</a></code></li>
<li><code><a title="raffiot.io.map_panic" href="#raffiot.io.map_panic">map_panic</a></code></li>
<li><code><a title="raffiot.io.panic" href="#raffiot.io.panic">panic</a></code></li>
<li><code><a title="raffiot.io.pure" href="#raffiot.io.pure">pure</a></code></li>
<li><code><a title="raffiot.io.read" href="#raffiot.io.read">read</a></code></li>
<li><code><a title="raffiot.io.recover" href="#raffiot.io.recover">recover</a></code></li>
<li><code><a title="raffiot.io.run" href="#raffiot.io.run">run</a></code></li>
<li><code><a title="raffiot.io.safe" href="#raffiot.io.safe">safe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a></code></h4>
<ul class="two-column">
<li><code><a title="raffiot.io.IO.ap" href="#raffiot.io.IO.ap">ap</a></code></li>
<li><code><a title="raffiot.io.IO.attempt" href="#raffiot.io.IO.attempt">attempt</a></code></li>
<li><code><a title="raffiot.io.IO.catch" href="#raffiot.io.IO.catch">catch</a></code></li>
<li><code><a title="raffiot.io.IO.contra_map_read" href="#raffiot.io.IO.contra_map_read">contra_map_read</a></code></li>
<li><code><a title="raffiot.io.IO.finally_" href="#raffiot.io.IO.finally_">finally_</a></code></li>
<li><code><a title="raffiot.io.IO.flat_map" href="#raffiot.io.IO.flat_map">flat_map</a></code></li>
<li><code><a title="raffiot.io.IO.flatten" href="#raffiot.io.IO.flatten">flatten</a></code></li>
<li><code><a title="raffiot.io.IO.map" href="#raffiot.io.IO.map">map</a></code></li>
<li><code><a title="raffiot.io.IO.map_error" href="#raffiot.io.IO.map_error">map_error</a></code></li>
<li><code><a title="raffiot.io.IO.map_panic" href="#raffiot.io.IO.map_panic">map_panic</a></code></li>
<li><code><a title="raffiot.io.IO.on_failure" href="#raffiot.io.IO.on_failure">on_failure</a></code></li>
<li><code><a title="raffiot.io.IO.recover" href="#raffiot.io.IO.recover">recover</a></code></li>
<li><code><a title="raffiot.io.IO.run" href="#raffiot.io.IO.run">run</a></code></li>
<li><code><a title="raffiot.io.IO.then" href="#raffiot.io.IO.then">then</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>