<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RAFFIOT Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="raffiot.html"><strong aria-hidden="true">1.</strong> Robust and Fast Functional IO Toolkit</a></li><li class="chapter-item expanded "><a href="first_steps.html"><strong aria-hidden="true">2.</strong> First Steps with IO</a></li><li class="chapter-item expanded "><a href="failures.html"><strong aria-hidden="true">3.</strong> Failures</a></li><li class="chapter-item expanded "><a href="context.html"><strong aria-hidden="true">4.</strong> Context</a></li><li class="chapter-item expanded "><a href="lists.html"><strong aria-hidden="true">5.</strong> Combining a list of IOs</a></li><li class="chapter-item expanded "><a href="async.html"><strong aria-hidden="true">6.</strong> Concurrent Programming</a></li><li class="chapter-item expanded "><a href="resource.html"><strong aria-hidden="true">7.</strong> Resource Management</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">8.</strong> Variables</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RAFFIOT Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="robust-and-fast-functional-io-toolkit"><a class="header" href="#robust-and-fast-functional-io-toolkit">Robust and Fast Functional IO Toolkit</a></h1>
<p><em>Raffiot</em> is small (almost) dependency-free python library providing some
usual functional tools. It currently provides</p>
<ul>
<li>an easy-to-use <code>IO</code> monad which is <strong>stack-safe</strong>, <strong>fast</strong>, support
<strong>asynchronous</strong>, <strong>concurrent</strong>, <strong>parallel</strong> programming, has many other features.</li>
<li>a <code>Resource</code> data type for easy but reliable <strong>resource management</strong>.</li>
<li>a <code>Result</code> data structure to represent errors</li>
</ul>
<h2 id="demo"><a class="header" href="#demo">Demo</a></h2>
<p>For a demo, just type this in a terminal:</p>
<pre><code class="language-shellscript">curl https://raw.githubusercontent.com/chrilves/raffiot.py/main/demos/raffiot_demo.sh | /bin/sh
</code></pre>
<p>This demo runs 4 computations in parallel. It demonstrates how simple concurrent
and parallel programing is in <em>raffiot</em>.</p>
<p><strong>Note that this command will install raffiot in your current Python environment</strong></p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="this-a-hrefindexhtmlguidea"><a class="header" href="#this-a-hrefindexhtmlguidea">This <a href="./index.html">Guide</a></a></h3>
<p>This guide will teach you how to use <em>Raffiot</em> through examples.
Just use the <strong>left panel</strong> or the <strong>right arrow</strong> on this page to jump to the next section.</p>
<h3 id="a-hrefapiindexhtmlapia"><a class="header" href="#a-hrefapiindexhtmlapia"><a href="./api/index.html">API</a></a></h3>
<p>The <a href="./api/index.html">API</a> is online at
<a href="./api/index.html">https://chrilves.github.io/raffiot.py/api/index.html</a>.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>pure python</strong>: <em>Raffiot</em> is written entirely in Python 3.7+.</li>
<li><strong>small</strong>: it is just a few small files.</li>
<li><strong>(almost) dependency-free</strong>: it only depends on <code>typing-extensions</code> (for the
<code>@final</code> annotation).</li>
<li><strong>crystal clear code</strong> </li>
</ul>
<h3 id="io"><a class="header" href="#io">IO</a></h3>
<ul>
<li><strong>stack safe</strong>: you just won't run into stack overflows anymore.</li>
<li><strong>fast</strong>: you won't notice the overhead.</li>
<li><strong>dependency injection</strong> <em>made easy</em>: make some context visible from anywhere.</li>
<li><em>simple</em> <strong>asynchronous</strong> <em>and</em> <strong>concurrent programming</strong>: full support of synchronous,
asynchronous and concurrent programming <em>with the same simple API</em>.</li>
<li><strong>railway-oriented programming</strong>: clean and simple failure management.</li>
<li><strong>distinction</strong> <em>between</em> <strong>expected and unexpected failures</strong>: some failures are part
of your program's normal behaviour (errors) while others are show something
terribly wrong happened (panics). Yes, that's heavily inspired by <em>Rust</em>.</li>
</ul>
<h3 id="resource"><a class="header" href="#resource">Resource</a></h3>
<p>Python has the <code>with</code> construction, but <code>Resource</code> goes a step further.</p>
<ul>
<li><strong>easy user-defined resource creation</strong>: just provide some open and close
function.</li>
<li><strong>composability</strong>: the resource you want to create depends on another resource?
Not a problem, you can compose resources the way you want. It scales.</li>
<li><strong>failures handling in resources</strong>: <code>Resource</code> has everything <code>IO</code> has, including
its wonderful failure management.</li>
</ul>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p>Did I mention <strong>Railway-Oriented Programming</strong>? <code>Result</code> is represent the 3 possible
result of a computation:</p>
<ul>
<li><code>Ok(value)</code>: the computation successfully computed the this <code>value</code>.</li>
<li><code>Errors(errors)</code>: the computation failed on some expected failures <code>errors</code>, probably
from the business domain.</li>
<li><code>Panic(exceptions, errors)</code>: the computation failed on some unexpected failures <code>exceptions</code>.
Note that there may be some domain errors too.</li>
</ul>
<h1 id="first-steps-with-io"><a class="header" href="#first-steps-with-io">First Steps with IO</a></h1>
<p><em>Raffiot</em> is available as a
<a href="https://pypi.org/project/raffiot/"><em>pip</em> package</a>
(and soon <em>conda</em>). For now just type this in a
terminal:</p>
<pre><code class="language-shell">$ pip install -U raffiot
</code></pre>
<p>This guide will teach you how to use <em>Raffiot</em> by exploring most of its features via the Python interactive shell (also known as Python's REPL):</p>
<pre><code class="language-shell">$ python
Python 3.9.1 (default, Dec 13 2020, 11:55:53) 
[GCC 10.2.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>Start by importing <em>Raffiot</em>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from raffiot import *
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h2>
<p>Let's start by the classic <em>&quot;Hello World!&quot;</em>:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,None] = io.defer(print, &quot;Hello World!&quot;)
</code></pre>
<p>As you can see, nothing is printed yet! The <code>defer</code> function delays the
execution of <code>print(&quot;Hello World!&quot;)</code> until the the value <code>main</code> is run.</p>
<p><strong>Very important</strong>: a value of type <code>IO</code>, like <code>main</code>, is the description
of some computation, very much like the text of a Python script.
Nothing is executed until the (value of type) <code>IO</code> is actually run, very
much like the code of Python script is only executed when this script is
run.</p>
<p>Inspecting the value <code>main</code>, gives you:</p>
<pre><code class="language-python">&gt;&gt;&gt; main
Defer((&lt;built-in function print&gt;, ('Hello World!',), {}))
</code></pre>
<p>Running an <code>IO</code> is very simple! Just call its <code>run</code> method like:</p>
<pre><code class="language-python">&gt;&gt;&gt; main.run(None)
Hello World!
Ok(success=None)
&gt;&gt;&gt; main.run(None)
Hello World!
Ok(success=None)
</code></pre>
<p>As you can see, every call to <code>run</code> printed <code>Hello World!</code> and returned
the value <code>Ok(None)</code>. <code>Ok</code> means the computation was successful, <code>None</code>
is the return value of computation.</p>
<h2 id="defer--doing-something-later"><a class="header" href="#defer--doing-something-later"><code>defer</code> : doing something <strong>later</strong></a></h2>
<p>The first argument of <code>defer</code> is the function you want to call later.
The following arguments are the function's normal arguments.
For example, to call <code>datetime.now()</code> later, just create the <code>IO</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from datetime import *
&gt;&gt;&gt; now : IO[None,None,datetime] = io.defer(datetime.now)
</code></pre>
<p>Every time you run it, it will call <code>datetime.now()</code> and give you
its result:</p>
<pre><code class="language-python">&gt;&gt;&gt; now.run(None)
Ok(success=datetime.datetime(2021, 2, 19, 18, 38, 42, 572766))
&gt;&gt;&gt; now.run(None)
Ok(success=datetime.datetime(2021, 2, 19, 18, 38, 47, 896153))
</code></pre>
<p><strong>In the type <code>IO[R,E,A]</code>, <code>A</code> is the type of values returned when the computation is successful</strong>.
<code>now</code> being of type <code>IO[None,None,datetime]</code>, it returns values
of type <code>datetime</code>.</p>
<p>Likewise, you can define the <code>print_io</code> function that prints its arguments
later:</p>
<pre><code class="language-python">&gt;&gt;&gt; def print_io(*args, **kwargs) -&gt; IO[None, None, None]:
...     return io.defer(print, *args, **kwargs)
</code></pre>
<p>Note that calling <code>print_io(&quot;Hello&quot;)</code> will not print anything but return
an <code>IO</code>. To actually print <code>Hello</code> you need to run the <code>IO</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; print_io(&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;)
Defer((&lt;built-in function print&gt;, ('Hello', 'World', '!'), {}))
&gt;&gt;&gt; print_io(&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;).run(None)
Hello World !
Ok(success=None)
</code></pre>
<p>This ability to represent any computation as a value is one of the main
strength of an <code>IO</code>. It means you can work with computation like any
other value: composing them, storing them in variables, in lists, etc.</p>
<h2 id="then--doing-something-sequentially"><a class="header" href="#then--doing-something-sequentially"><code>then</code> : doing something sequentially.</a></h2>
<p>You will often need to execute some <code>IO</code> sequentially.
The method <code>then</code> compose some values of type <code>IO</code>, running
them one by one. The return value is the one of the last <code>IO</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,datetime] = print_io(&quot;First line&quot;).then(
...   print_io(&quot;Second line&quot;),
...   print_io(&quot;Third line&quot;),
...   now
... )
&gt;&gt;&gt; main.run(None)
First line
Second line
Third line
Ok(success=datetime.datetime(2021, 2, 20, 15, 52, 11, 205845))
</code></pre>
<p>You may sometimes prefer the analogous function <code>io.sequence</code>
that behaves like the method <code>then</code>.</p>
<h2 id="map--transforming-results"><a class="header" href="#map--transforming-results"><code>map</code> : transforming results.</a></h2>
<p>You can transform the return value of an <code>IO</code> using the <code>map</code> method.
It is very similar to the <code>map</code> function on lists, but works on <code>IO</code>.
Just provide <code>map</code> some function. It will use this function to transform
the <code>IO</code> return value:</p>
<pre><code class="language-python">&gt;&gt;&gt; date_str : IO[None,None,str] = now.map(lambda d: d.isoformat())
&gt;&gt;&gt; date_str
Map((Defer((&lt;built-in method now of type object at 0x7ff733070bc0&gt;,
 (), {})), &lt;function &lt;lambda&gt; at 0x7ff7338d9280&gt;))
&gt;&gt;&gt; date_str.run(None)
Ok(success='2021-02-19T23:54:46.297503')
</code></pre>
<h2 id="flat_map--chaining-ios"><a class="header" href="#flat_map--chaining-ios"><code>flat_map</code> : chaining IOs.</a></h2>
<p><code>map</code> transform the return value of an <code>IO</code>. So transforming the
return value of <code>date_str</code> with <code>print_io</code> will give you an  <code>IO</code>
whose return value is also an <code>IO</code>. When you will run it, instead
if executing the inner <code>IO</code>, it will return it to you:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,IO[None,None,None]] = date_str.map(lambda x: print_io(x))
&gt;&gt;&gt; main.run(None)
Ok(success=Defer((&lt;built-in function print&gt;, ('2021-02-20T15:54:38.444494',), {})))
</code></pre>
<p>When you want to use the result of some <code>IO</code> into some other <code>IO</code>,
use <code>flat_map</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; main: IO[None,None,None] = date_str.flat_map(lambda x: print_io(x))
&gt;&gt;&gt; main.run(None)
2021-02-20T15:55:13.940717
Ok(success=None)
</code></pre>
<p>Here the return value of <code>date_str</code> is given to <code>print_io</code> via <code>x</code> and
both <code>IO</code> are executed, returning the result of <code>print_io(x)</code>.</p>
<h2 id="flatten--concatenating-an-io-of-io"><a class="header" href="#flatten--concatenating-an-io-of-io"><code>flatten</code> : concatenating an IO of IO.</a></h2>
<p>Instead of having used <code>flat_map</code>, you could have used <code>map</code> and then
<code>flatten</code> to reduce the <code>IO of IO</code> into a single layer of <code>IO</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,None]= date_str.map(lambda x: print_io(x)).flatten()
&gt;&gt;&gt; main.run(None)
2021-02-20T15:58:44.244715
Ok(success=None)
</code></pre>
<p>Most of the time, you will use <code>flat_map</code> because it is simpler to use.
But now you know where its name comes from: flatten of map.</p>
<h2 id="pure--just-a-value"><a class="header" href="#pure--just-a-value"><code>pure</code> : just a value.</a></h2>
<p><code>pure</code> is very simple: the result of the computation is the very same
argument of <code>pure</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,int] = io.pure(5)
&gt;&gt;&gt; main
Pure(5)
&gt;&gt;&gt; main.run(None)
Ok(success=5)
</code></pre>
<p>It is very useful when some functions/method expect some <code>IO</code>
but you want to provide a constant.</p>
<h2 id="defer_io--computing-an-io-later"><a class="header" href="#defer_io--computing-an-io-later"><code>defer_io</code> : computing an IO later.</a></h2>
<p><code>defer_io</code> is very much like <code>defer</code> but for functions returning <code>IO</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,IO[None,None,None]] = io.defer(print_io, &quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;)
&gt;&gt;&gt; main.run(None)
Ok(success=Defer((&lt;built-in function print&gt;, ('Hello', 'World', '!'), {})))
&gt;&gt;&gt; main : IO[None,None,None] = io.defer_io(print_io, &quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;)
&gt;&gt;&gt; main.run(None)
Hello World !
Ok(success=None)
</code></pre>
<p>Like <code>flat_map</code> is <code>faltten</code> of <code>map</code>, <code>defer_io</code> is <code>flatten</code> of <code>defer</code>.
It is useful to defer the call of function returning <code>IO</code>.</p>
<h2 id="use-case-stack-safety"><a class="header" href="#use-case-stack-safety">Use Case: Stack-Safety</a></h2>
<p>Let's see one of the main feature of <code>IO</code>: it is stack safe!
When you run the following function in Python, even if the
argument <code>times</code> is small, the computation will fail miserably
because it blew the stack:</p>
<pre><code class="language-python">&gt;&gt;&gt; def print_date(times: int) -&gt; None:
...   if times &gt; 0:
...     d = datetime.now()
...     print(d.isoformat())
...     print_date(times - 1)
&gt;&gt;&gt; print_date(1000)
&lt;LOTS OF DATES&gt;
2021-02-20T16:20:37.188880
2021-02-20T16:20:37.188883
2021-02-20T16:20:37.188886
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 5, in print_date
  File &quot;&lt;stdin&gt;&quot;, line 5, in print_date
  File &quot;&lt;stdin&gt;&quot;, line 5, in print_date
  [Previous line repeated 992 more times]
  File &quot;&lt;stdin&gt;&quot;, line 4, in print_date
RecursionError: maximum recursion depth exceeded while calling a Python object
2021-02-20T16:20:37.188889
</code></pre>
<p>On the contrary, the equivalent function using <code>IO</code> will never
blew the stack, even for very high values of <code>times</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; def print_date_io(times: int) -&gt; IO[None, None, None]:
...   if times &gt; 0:
...     return (
...       now
...       .flat_map(lambda d: print_io(d.isoformat()))
...       .flat_map(lambda _: print_date_io(times - 1))
...     )
...   else
...     return io.pure(None)
&gt;&gt;&gt; print_date(1000000)
&lt;LOTS OF DATES&gt;
2021-02-20T16:23:22.968454
2021-02-20T16:23:22.968464
Ok(success=None)
</code></pre>
<p>With <code>IO</code>, you can use recursion without fear! Just remember to
wrap your computation in an <code>IO</code> (using <code>defer</code>, <code>defer_io</code>, <code>map</code>,
<code>flat_map</code>and others) to benefit from <code>IO</code>'s safety.</p>
<h1 id="failures"><a class="header" href="#failures">Failures</a></h1>
<p>All the computation we have seen until now were successful.
We will now see how <code>IO</code>'s failure management works.
But before, I need to present you the <code>Result[E,A]</code> type.</p>
<h2 id="the-resultea-type"><a class="header" href="#the-resultea-type">The <code>Result[E,A]</code> type</a></h2>
<p><code>Result[E,A]</code> represent the result of a computation.
A computation can either be successful, returning a value of type <code>A</code>,
or have failed on some expected errors of type <code>E</code>, or failed one some
unexpected exceptions.
<code>IO</code> and <code>Result</code> make a distinction between expected failures,
called <em>errors</em>, and unexpected failures, called <em>panics</em>.</p>
<p>For an operating system, an application crashing is an expected error.
A well designed operating system is expected to be prepared to such
errors. It has to deal with situations like this nicely and continue
running normally. Errors are part of the normal life of your program.
An error means that some operation failed but your program is still
healthy.</p>
<p>On the contrary, memory corruption inside the kernel is an unexpected
error. The system can not continue running normally. The failure may
have made the computation dangerous and/or the result wrong. The only
option is terminating the system as smoothly as possible.
Panics should never happen, but sometimes even the most improbable events
do occur. When panics happen, consider your computation lost. Terminate
it doing as little damage as possible.</p>
<p><em>Raffiot</em> is designed to <strong>report all encountered failures</strong>. Failures are
never silently ignored but exposed via the <code>Result</code> type. This is why the
<code>Result</code> type works with lists of domain failures (<em>errors</em>) and unexpected
failures (<em>panics</em>).</p>
<p>For the rest of this section, you will need these imports.</p>
<pre><code class="language-python">&gt;&gt;&gt; from raffiot import *
</code></pre>
<h3 id="oksuccessa--a-success"><a class="header" href="#oksuccessa--a-success"><code>Ok(success:A)</code> : A Success</a></h3>
<p>When a computation successfully return some value <code>a</code> of type <code>A</code>,
it actually returns the value <code>Ok(a)</code> of type <code>Result[E,A]</code>. The
value <code>a</code> can be obtained by <code>Ok(a).success</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from typing import Any
&gt;&gt;&gt; r : Result[Any,int] = Ok(5)
&gt;&gt;&gt; r
Ok(success=5)
&gt;&gt;&gt; r.success
5
</code></pre>
<h3 id="errorserrorsliste--some-expected-failures"><a class="header" href="#errorserrorsliste--some-expected-failures"><code>Errors(errors:List[E])</code> : Some Expected Failures</a></h3>
<p>When a computation fail because of an error <code>e</code> of type <code>E</code>,
it actually return a value <code>Errors(errors=[e])</code> of type <code>Result[E,Any]</code>.
The type <code>E</code> can be any type you want. Choose as type <code>E</code> a type
that fit your business domain errors the best.
The list of all errors encountered can be obtained by <code>Errors([e]).errors</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; r : Result[int,Any] = Errors([5])
&gt;&gt;&gt; r
Errors(errors=[5])
&gt;&gt;&gt; r.errors
5
</code></pre>
<p>Note that you must <strong>ALWAYS</strong> provide a <strong>list</strong> to <code>Errors! So, to avoid bugs, please use the method </code>result.error(e: E) -&gt; Result[E,Any]<code>when you want to raise a single error or</code>result.errors(e1:E, e2:E, ...) -&gt; Result[E,Any]` when
you want to raise several errors:</p>
<pre><code class="language-python">&gt;&gt;&gt; result.error(5)
Errors(errors=[5])
&gt;&gt;&gt; result.errors(5, 2)
Errors(errors=[5, 2])
</code></pre>
<h3 id="panicexceptions-listexception-errors-liste--some-unexpected-failures"><a class="header" href="#panicexceptions-listexception-errors-liste--some-unexpected-failures"><code>Panic(exceptions: List[Exception], errors: List[E])</code> : Some Unexpected Failures</a></h3>
<p>When a computation fail because of an unexpected failure,
it actually return a value <code>Panic(exceptions=[p],errors=[])</code> of type <code>Result[Any,Any]</code>
where <code>p</code> is the exception encountered.
The exception type is always the Python exception type <code>Exception</code>.
The exceptions encountered can be obtained by <code>Panic([p],[]).exceptions</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; r : Result[Any,Any] = Panic(exceptions=[Exception(&quot;BOOM!&quot;)], errors=[])
&gt;&gt;&gt; r
Panic(exceptions=[Exception('BOOM!')], errors=[])
&gt;&gt;&gt; r.exceptions
[Exception('BOOM!')]
&gt;&gt;&gt; r.errors
[]
</code></pre>
<p>When an unexpected failures happen, there may have already been some expected
failures. This is why the <code>Panic</code> case have a list of errors slot. The list
of exceptions should never be empty (otherwise it shouldn't be a <code>Panic</code>).
Using the <code>Panic</code> constructor is error-prone as you <strong>must always provide lists</strong>
for the <code>exceptions</code>and <code>errors</code>field. Instead you can use the helper function
<code>result.panic</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; result.panic(Exception(&quot;BOOM&quot;))
Panic(exceptions=[Exception('BOOM')], errors=[])
&gt;&gt;&gt; result.panic(Exception(&quot;BOOM 1&quot;), Exception(&quot;BOOM 2&quot;))
Panic(exceptions=[Exception('BOOM 1'), Exception('BOOM 2')], errors=[])
&gt;&gt;&gt; result.panic(Exception(&quot;BOOM 1&quot;), Exception(&quot;BOOM 2&quot;), errors=[5,2])
Panic(exceptions=[Exception('BOOM 1'), Exception('BOOM 2')], errors=[5, 2])
</code></pre>
<h3 id="fold--transforming-a-resultea"><a class="header" href="#fold--transforming-a-resultea"><code>fold</code> : transforming a <code>Result[E,A]</code></a></h3>
<p>To transform a <code>Result[E,A]</code>, use the method <code>fold</code>. It takes
as argument three functions. The first one is called when the
result is an <code>Ok</code>. The second is called when it are some <code>Errors</code>.
The third is called on <code>Panic</code>. When called, each of
these function receive as argument the value/list of errors/list exceptions and
errors (depending on the case) stored in the result:</p>
<pre><code class="language-python">&gt;&gt;&gt; Ok(5).fold(
...   lambda s: f&quot;success: {s}&quot;,
...   lambda e: f&quot;errors: {e}&quot;,
...   lambda p,e: f&quot;exeptions: {p}, errors: {e}&quot;
... )
'success: 5'
&gt;&gt;&gt; result.errors(7,5).fold(
...   lambda s: f&quot;success: {s}&quot;,
...   lambda e: f&quot;errors: {e}&quot;,
...   lambda p,e: f&quot;exeptions: {p}, errors: {e}&quot;
... )
'error: [7,5]'
&gt;&gt;&gt; result.panic(Exception(&quot;BOOM 1&quot;), Exception(&quot;BOOM 2&quot;), errors=[5,2]).fold(
...   lambda s: f&quot;success: {s}&quot;,
...   lambda e: f&quot;errors: {e}&quot;,
...   lambda p,e: f&quot;exeptions: {p}, errors: {e}&quot;
... )
&quot;exeptions: [Exception('BOOM 1'), Exception('BOOM 2')], errors: [5, 2]&quot;
</code></pre>
<h3 id="raise_on_panic--reporting-panics-as-exceptions"><a class="header" href="#raise_on_panic--reporting-panics-as-exceptions"><code>raise_on_panic</code> : reporting panics as exceptions</a></h3>
<p><em>Raffiot</em>'s functions and methods never raise exception
but instead return a <code>Panic</code>. When you need a failed
computation to raise the exception, call <code>raise_on_panic</code>
on the result:</p>
<pre><code class="language-python">&gt;&gt;&gt; Ok(5).raise_on_panic()
Ok(success=5)
&gt;&gt;&gt; result.error(7).raise_on_panic()
Errors(errors=[7])
&gt;&gt;&gt; result.panic(Exception(&quot;BOOM!&quot;)).raise_on_panic()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/home/tof/dev/raffiot.py/raffiot/result.py&quot;, line 434, in raise_on_panic
    raise MultipleExceptions.merge(*self.exceptions, errors=self.errors)
Exception: BOOM!
</code></pre>
<p><code>raise_on_panic</code> is <strong>the only function/method raising exceptions</strong>.
Never expect other functions to raise exception on failures, they
will return an <code>Errors</code> or <code>Panic</code> instead:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,None] = io.panic(Exception(&quot;BOOM!&quot;))
&gt;&gt;&gt; main.run(None)
Panic(exceptions=[Exception('BOOM!')], errors=[])
&gt;&gt;&gt; main.run(None).raise_on_panic()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/home/tof/dev/raffiot.py/raffiot/result.py&quot;, line 434, in raise_on_panic
    raise MultipleExceptions.merge(*self.exceptions, errors=self.errors)
Exception: BOOM!
</code></pre>
<h2 id="errors-expected-failures-in-io"><a class="header" href="#errors-expected-failures-in-io">Errors: Expected failures in IO</a></h2>
<p><code>IO</code> has built-in support errors. Remember that we call error the
expected failures. Errors can be of any type you want. You should
usually take as error type the one that fit your business domain
errors the best. <strong>In the type <code>IO[R,E,A]</code>, <code>E</code> is the type of errors</strong>.</p>
<h3 id="error--this-failure-was-expected-were-still-in-safe-zone"><a class="header" href="#error--this-failure-was-expected-were-still-in-safe-zone"><code>error</code> : this failure was expected, we're still in safe zone!</a></h3>
<p>To raise an error, simply call <code>io.error</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from typing import Any, List

&gt;&gt;&gt; main_str : IO[None,str,Any] = io.error(&quot;Oops&quot;)
&gt;&gt;&gt; main_str.run(None)
Errors(errors=['Oops'])

&gt;&gt;&gt; main_int : IO[None,int,Any] = io.error(5)
&gt;&gt;&gt; main_int.run(None)
Errors(errors=[5])

&gt;&gt;&gt; main_list : IO[None,List[int],Any] = io.error([1,2,3])
&gt;&gt;&gt; main_list.run(None)
Error(error=[[1, 2, 3]])
</code></pre>
<h3 id="errors--raising-several-errors-at-once"><a class="header" href="#errors--raising-several-errors-at-once"><code>errors</code> : raising several errors at once.</a></h3>
<p>To raise several errors, simply call <code>io.errors</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from typing import Any, List

&gt;&gt;&gt; main_str : IO[None,str,Any] = io.errors(&quot;Oops1&quot;, &quot;Oops2&quot;)
&gt;&gt;&gt; main_str.run(None)
Errors(errors=['Oops1', 'Oops2'])

&gt;&gt;&gt; main_int : IO[None,int,Any] = io.errors(5,7)
&gt;&gt;&gt; main_int.run(None)
Errors(errors=[5, 7])
</code></pre>
<p><strong>But beware</strong>: the iterable arguments will be treated as collections of errors
and not a single error. For example the error <code>[1,2,3]</code> will be treated by
<code>io.errors</code> as three errors <code>1</code>, <code>2</code> and <code>3</code>. So when you want to raise iterable
errors, use <code>io.error</code> instead:</p>
<pre><code class="language-python">&gt;&gt;&gt; main_list : IO[None,List[int],Any] = io.errors([1,2,3])
&gt;&gt;&gt; main_list.run(None)
Errors(errors=[1, 2, 3])
</code></pre>
<h3 id="catch--reacting-to-expected-failures-to-continue"><a class="header" href="#catch--reacting-to-expected-failures-to-continue"><code>catch</code> : reacting to expected failures to continue.</a></h3>
<p>To react to errors, just call the method <code>catch</code>.
It is very similar to a <code>try-exept</code> block.
It takes as argument a function called the <em>error handler</em>.
When the computation fails because of some errors <code>le: List[E]</code>,
the error handler is called with <code>le</code> as argument.
The result is then the error handler's result.</p>
<pre><code class="language-python">&gt;&gt;&gt; def main(i: int) -&gt; IO[None,str,int]:
...   return (
...   io.error(i)
...   .catch(lambda x:
...     io.pure(2*x[0])
...     if x[0] % 2 == 0
...     else io.error(&quot;Oops&quot;))
... )
&gt;&gt;&gt; main(5).run(None)
Errors(errors=['Oops'])
&gt;&gt;&gt; main(6).run(None)
Ok(success=12)
</code></pre>
<p>If the computation is successful, or if it failed on a panic,
then <code>catch</code> has no effect.
Note that the error handler can itself raise errors and panics.</p>
<h3 id="map_error--transforming-expected-failures"><a class="header" href="#map_error--transforming-expected-failures"><code>map_error</code> : transforming expected failures.</a></h3>
<p>It is often useful to transform an error. For example you may
want to add some useful information about the context: what
was the request that led to this error, what were the arguments
of the operation that failed, etc.</p>
<p>To transform an error, call <code>map_error</code>. It behaves like <code>map</code>,
but on errors:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,int,Any] = io.error([1,2]).map_error(lambda l: l[0] + l[1])
&gt;&gt;&gt; main.run(None)
Errors(errors=[3])
</code></pre>
<p>If the computation is successful or if it fails on a panic,
then <code>map_error</code> has no effect.</p>
<h2 id="panics-unexpected-failures-in-io"><a class="header" href="#panics-unexpected-failures-in-io">Panics: Unexpected Failures in IO</a></h2>
<p>The type of panics is always the Python type of exception <code>Exception</code>.
Panics can be raise either manually, by calling <code>io.panic</code>, or
when <code>run</code> encounters an exception.
<strong>The method <code>run</code> on <code>IO</code> never raises exceptions!</strong>
Every exception <code>p</code> raised during the execution of <code>run</code> are caught and
transformed into panics <code>result.panic(p)</code>.</p>
<h3 id="all-exceptions-are-caught"><a class="header" href="#all-exceptions-are-caught"><strong>ALL</strong> exceptions are caught</a></h3>
<p>All the functions and method that accept functions as arguments
run them inside a <code>try-except</code> block to catch every raised exception.
All exception caught this way are transformed into panics:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,float] = io.pure(0).map(lambda x: 1/x)
&gt;&gt;&gt; main.run(None)
Panic(exceptions=[ZeroDivisionError('division by zero')], errors=[])
</code></pre>
<p>Remember that panics are unexpected failures and unexpected failures
should never happen. In an ideal world you should never give to
<code>map</code>, <code>flat_map</code>, <code>defer</code> and others functions that may raise exceptions.
In an ideal world, panics would never occur. But we do not live in an
ideal world, so <code>map</code>, <code>flat_map</code> and others covers your back by
catching any exception for your own safety.</p>
<h3 id="panic--something-went-terribly-wrong-were-in-unsafe-zone"><a class="header" href="#panic--something-went-terribly-wrong-were-in-unsafe-zone"><code>panic</code> : something went terribly wrong, we're in <strong>unsafe</strong> zone.</a></h3>
<p>It is sometimes useful to manually raise panics. For example when
you encounter a problematic situation you though were impossible
but still did happen. If your program is not designed to handle this
situation, you should raise a panic.</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,Any] = io.panic(Exception(&quot;BOOM!&quot;))
&gt;&gt;&gt; main.run(None)
Panic(exceptions=[Exception('BOOM!')], errors=[])
</code></pre>
<p>The function <code>io.panic</code> accepts several exceptions as arguments and even
domain errors with the <code>errors</code> keyword argument.</p>
<h3 id="recover--stopping-the-computation-safely-after-an-unexpected-failure"><a class="header" href="#recover--stopping-the-computation-safely-after-an-unexpected-failure"><code>recover</code> : <strong>stopping</strong> the computation safely after an unexpected failure.</a></h3>
<p>Even in case of a panic, you have a chance to perform some emergency
actions to recover. For example, you may want to restart the computation
on panics. To react to panics, just call <code>recover</code>.
It is very similar to a <code>try-exept</code> block.
It takes as argument a function, called the <em>panic handler</em>.
If the computation fails because of a panic with exceptions <code>lexn: List[Exception]</code>,
and errors <code>lerr: List[E]</code>, then the panic handler is called with <code>lexn</code> as
first argument and <code>lerr</code>as its second argument.
The result is then the the handler's result.</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,Any] = (
...   io.panic(Exception(&quot;BOOM!&quot;))
...   .recover(lambda lexn, lerr: io.pure(f&quot;Recovered from exceptions: {lexn} and errors {lerr}&quot;))
... )
&gt;&gt;&gt; main.run(None)
Ok(success=&quot;Recovered from exceptions: [Exception('BOOM!')] and errors []&quot;)
</code></pre>
<h3 id="map_panic--transforming-exceptions"><a class="header" href="#map_panic--transforming-exceptions"><code>map_panic</code> : transforming exceptions.</a></h3>
<p>It is often useful to transform a panic. For example you may
want to add some useful information about the context: what
was the request that led to this error, what were the arguments
of the operation that failed, etc.</p>
<p>To transform all the exceptions of a <code>Panic</code>, call <code>map_panic</code>.
It behaves like <code>map</code>, but on exceptions contained in <code>Panic</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None, None, None] = (
...   io.pure(0)
...   .map(lambda x: 1/x)
...   .map_panic(lambda exception: Exception(&quot;BOOM&quot;))
... )
&gt;&gt;&gt; main.run(None)
Panic(exceptions=[Exception('BOOM')], errors=[])
</code></pre>
<h3 id="more-tools"><a class="header" href="#more-tools">More tools</a></h3>
<p>Here are some very useful functions. They can all be expressed using the
functions and methods seen above but they deserve being seeing in details:</p>
<h3 id="attempt--failures-as-values"><a class="header" href="#attempt--failures-as-values"><code>attempt</code> : failures as values.</a></h3>
<p>The method <code>attemp</code> transform an <code>IO[R,E,A]</code> into
<code>IO[R,None,Result[E,A]]</code>. If the original computation is successful,
the transformed one returns an <code>Ok(Ok(...))</code>. If the original computation fails
on some errors, the transformed one returns <code>Ok(Errors(...))</code>.
If the original computation fails on a panic, the transformed one returns <code>Ok(Panic(...))</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; io_ok : IO[None,None,Result[None,int]] = io.pure(5).attempt()
&gt;&gt;&gt; io_ok.run(None)
Ok(success=Ok(success=5))
&gt;&gt;&gt; io_error : IO[None,None,Result[int,None]] = io.error(7).attempt()
&gt;&gt;&gt; io_error.run(None)
Ok(success=Errors(errors=[7]))
&gt;&gt;&gt; io_panic : IO[None,None,Result[None,None]] = io.panic(Exception(&quot;BOOM!&quot;)).attempt()
&gt;&gt;&gt; io_panic.run(None)
Ok(success=Panic(exceptions=[Exception('BOOM!')], errors=[]))
</code></pre>
<p>It is hugely useful when you want to do different actions depending
on the result of a computation. Calling <code>attempt</code> and <code>flat_map</code> is
easier than combining <code>flat_map</code>, <code>catch</code> and <code>recover</code> correctly.</p>
<h3 id="from_result--from-resultea-to-iononeea"><a class="header" href="#from_result--from-resultea-to-iononeea"><code>from_result</code> : from <code>Result[E,A]</code> to <code>IO[None,E,A]</code></a></h3>
<p>The function <code>io.from_result</code> does almost the opposite of <code>attempt</code>.
It transform a <code>Result[E,A]</code> into the corresponding <code>IO[None,E,A]</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; io_ok : IO[None,None,int] = io.from_result(Ok(5))
&gt;&gt;&gt; io_ok.run(None)
&gt;&gt;&gt; io_error : IO[None,int,None] = io.from_result(result.error(5))
&gt;&gt;&gt; io_error.run(None)
Errors(errors=[5])
&gt;&gt;&gt; io_panic : IO[None,None,None] = io.from_result(result.panic(Exception(&quot;BOOM!&quot;)))
&gt;&gt;&gt; io_panic.run(None)
Panic(exceptions=[Exception('BOOM!')], errors=[])
</code></pre>
<p><code>from_result</code> is often useful after an <code>attempt</code> to restore the state
of the computation.</p>
<h3 id="finally_--doing-something-unconditionally"><a class="header" href="#finally_--doing-something-unconditionally"><code>finally_</code> : doing something unconditionally.</a></h3>
<p>The method <code>finally_</code> is the <em>finally</em> clause of a <em>try-except-finally</em>.
It executed a <code>IO</code> after the current one, discard its result and
restore the result of the current one. The <code>IO</code> executed after is actually
a function taking as argument a <code>Result[R,E]</code> from the preceding <code>IO</code>.
It enables to perform different actions depending on the result of the first
computation:</p>
<pre><code class="language-python">&gt;&gt;&gt; io.pure(5).finally_(lambda r: io.defer(print, f&quot;Hello, result is {r}&quot;)).run(None)
Hello, result is Ok(success=5)
Ok(success=5)
&gt;&gt;&gt; io.error(7).finally_(lambda r: io.defer(print, f&quot;Hello, result is {r}&quot;)).run(None)
Hello, result is Errors(errors=[7])
Errors(errors=[7])
&gt;&gt;&gt; io.panic(Exception(&quot;BOOM!&quot;)).finally_(lambda r: io.defer(print, f&quot;Hello, result is {r}&quot;)).run(None)
Hello, result is Panic(exceptions=[Exception('BOOM!')], errors=[])
Panic(exceptions=[Exception('BOOM!')], errors=[])
</code></pre>
<h3 id="on_failure--reaction-to-both-errors-and-panics"><a class="header" href="#on_failure--reaction-to-both-errors-and-panics"><code>on_failure</code> : reaction to both errors and panics.</a></h3>
<p>Calling both methods <code>catch</code> and <code>recover</code> is sometimes annoying.
When you need to react to any failure, call <code>on_failure</code>. It
takes as argument a function called the <em>failure handler</em>.
When a computation fails, it calls the failure handler with the
failure passed as argument as a <code>Result[E,None]</code>.</p>
<p>This <code>Result[E,None]</code> is never <code>Ok</code> because <code>on_failure</code> call the handler
only on failures.</p>
<pre><code class="language-python">&gt;&gt;&gt; io.pure(5).on_failure(lambda x: io.pure(12)).run(None)
Ok(success=5)
&gt;&gt;&gt; io.error(7).on_failure(lambda x: io.pure(12)).run(None)
Ok(success=12)
&gt;&gt;&gt; io.panic(Exception(&quot;BOOM!&quot;)).on_failure(lambda x: io.pure(12)).run(None)
Ok(success=12)
</code></pre>
<h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>The time has come to talk about the third type parameter of an <code>IO</code>.
<strong>In the type <code>IO[R,E,A]</code>, <code>R</code> is the type of the context</strong>.
The context is a value that is always accessible to any <code>IO</code>.
You can think of it as a local global variable.
I assure you this sentence make sense!</p>
<h2 id="run--executing-an-io-in-a-given-context"><a class="header" href="#run--executing-an-io-in-a-given-context"><code>run</code> : executing an <code>IO</code> in a given context.</a></h2>
<p>We have called the method <code>run</code> many times. And every time we gave it
<code>None</code> as argument. The argument you give to <code>run</code> is actually the
context value. You take any value you want as the context.
Usually the context is a value you want to be accessible from everywhere.</p>
<p>Global variables are indeed accessible from everywhere but they
are very annoying because they can only have one value at a time.
Furthermore every change made to the global variable by a part of
your code will affect all other parts reading this global variable.</p>
<p>On the opposite side, local variable are nice because every part
of your code can have its own dedicated local variable. But they
are annoying because to make them accessible everywhere, you have
to pass it to every functions as parameters. This is error prone and pollutes your code.</p>
<p>Given an <code>IO</code> named <code>main</code>, when you call <code>run</code> with some context <code>r</code>,
the value <code>r</code> is accessible from everywhere in <code>main</code>.
The context behaves like a global variable inside the running <code>IO</code>.
But you can pass every call to <code>run</code> a different context.
The context behaves like a local variable between different calls to <code>run</code>.</p>
<h2 id="read--accessing-the-shared-context"><a class="header" href="#read--accessing-the-shared-context"><code>read</code> : accessing the shared context.</a></h2>
<p>To access the context, just call the function <code>io.read</code>. Its result
is the context:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[int,None,int] = io.read
&gt;&gt;&gt; main.run(5)
Ok(success=5)
&gt;&gt;&gt; main.run(77)
Ok(success=77)
</code></pre>
<p>This example is indeed trivial. But imagine that <code>main</code> can be
a very big program. You can call <code>io.read</code> anywhere in <code>main</code> to
get the context. It saves you the huge burden of passing the context
from <code>run</code> to every function until it reaches the location of <code>io.read</code>.</p>
<h2 id="contra_map_read--transforming-the-shared-context"><a class="header" href="#contra_map_read--transforming-the-shared-context"><code>contra_map_read</code> : transforming the shared context.</a></h2>
<p>As I said, the context behaves as a local global variable.
With <code>io.read</code> you have seen its global behaviour.
The method <code>contra_map_read</code> transforms the context, but only
for the <code>IO</code> it is being called on.
Note that the context is transformed before the <code>IO</code> is executed.</p>
<p>The method <code>contra_map_read</code> is very useful when you need to
alter the context. For example, your program may start with <code>None</code>
as context, read its configuration to instantiate the services it wants
to inject and then change to context to pass these services everywhere
for dependency injection.</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[str,None,int] = io.read.contra_map_read(lambda s: len(s))
&gt;&gt;&gt; main.run(&quot;Hello&quot;)
Ok(success=5)
</code></pre>
<h2 id="defer_read--doing-something-context-dependent-later"><a class="header" href="#defer_read--doing-something-context-dependent-later"><code>defer_read</code> : doing something context-dependent later.</a></h2>
<p>The function <code>io.defer_read</code> is useful when you it is easier to
implement an <code>IO</code> as a normal function and then transform it into an <code>IO</code>.
<code>io.defer_read</code>, like <code>io.defer</code>, takes as first argument the function
you want to execute later. But unlike <code>io.defer</code>, this function:</p>
<ul>
<li>has access to the context</li>
<li>returns a <code>Result[E,A]</code></li>
</ul>
<p>The last point is important because it means the function can raise
errors while <code>io.defer</code> can only raise panics.</p>
<pre><code class="language-python">&gt;&gt;&gt; def f(context:int, i: int) -&gt; Result[str,int]:
...   if context &gt; 0:
...     return result.ok(context + i)
...   else:
...     return result.error(&quot;Ooups!&quot;)
&gt;&gt;&gt; main : IO[int,None,int] = io.defer_read(f, 5)
&gt;&gt;&gt; main.run(10)
Ok(success=15)
&gt;&gt;&gt; main.run(-1)
Error(error='Ooups!')
</code></pre>
<h2 id="defer_read_io--computing-a-context-dependent-io-later"><a class="header" href="#defer_read_io--computing-a-context-dependent-io-later"><code>defer_read_io</code> : computing a context-dependent IO later.</a></h2>
<p>The function <code>io.defer_read_io</code> is the <code>IO</code> counterpart of
<code>io.defer_read</code>. It is useful when the context-aware function you want
to execute later returns an <code>IO</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; def f(context:int, i:int) -&gt; IO[None,str,int]:
...   if context &gt; 0:
...     return io.pure(context + i)
...   else:
...     return io.error(&quot;Ooups!&quot;)
&gt;&gt;&gt; main : IO[int,None,int] = io.defer_read_io(f, 5)
&gt;&gt;&gt; main.run(10)
Ok(success=15)
&gt;&gt;&gt; main.run(-1)
Errors(errors=['Ooups!'])
</code></pre>
<h2 id="use-case-dependency-injection"><a class="header" href="#use-case-dependency-injection">Use Case: Dependency Injection</a></h2>
<p>As a demonstration of how dependency injection works in <em>Raffiot</em>,
create and fill the file <code>dependency_injection.py</code> as below:</p>
<pre><code class="language-python">from raffiot import *

import sys
from dataclasses import dataclass
from typing import List

@dataclass
class NotFound(Exception):
  url: str

class Service:
  def get(self, path: str) -&gt; IO[None,NotFound,str]:
    pass

class HttpService(Service):
  def __init__(self, host: str, port: int) -&gt; None:
    self.host = host
    self.port = port
  
  def get(self, path: str) -&gt; IO[None,NotFound,str]:
    url = f&quot;http://{self.host}:{self.port}/{path}&quot;

    if path == &quot;index.html&quot;:
      response = io.pure(f&quot;HTML Content of url {url}&quot;)
    elif path == &quot;index.md&quot;:
      response = io.pure(f&quot;Markdown Content of url {url}&quot;)
    else:
      response = io.error(NotFound(url))
    return io.defer(print, f&quot;Opening url {url}&quot;).then(response)

class LocalFileSytemService(Service):
  def get(self, path: str) -&gt; IO[None,NotFound,str]:
    url = f&quot;/{path}&quot;

    if path == &quot;index.html&quot;:
      response = io.pure(f&quot;HTML Content of file {url}&quot;)
    elif path == &quot;index.md&quot;:
      response = io.pure(f&quot;Markdown Content of file {url}&quot;)
    else:
      response = io.error(NotFound(url))
    return io.defer(print, f&quot;Opening file {url}&quot;).then(response)


main : IO[Service,NotFound,List[str]] = (
  io.read
  .flat_map(lambda service:
    service.get(&quot;index.html&quot;)
    .flat_map(lambda x:
      service.get(&quot;index.md&quot;)
      .flat_map(lambda y: io.defer(print, &quot;Result = &quot;, [x,y]))
    )
  )
)

if len(sys.argv) &gt;= 2 and sys.argv[1] == &quot;http&quot;:
  service = HttpService(&quot;localhost&quot;, 80)
else:
  service = LocalFileSytemService()

main.run(service)
</code></pre>
<p>Running the program with the <code>HTTPService</code> gives:</p>
<pre><code class="language-shell">$ python dependency_injection.py http
Opening url http://localhost:80/index.html
Opening url http://localhost:80/index.md
Result =  ['HTML Content of url http://localhost:80/index.html', 'Markdown Content of url http://localhost:80/index.md']
</code></pre>
<p>While running it with the <code>LocalFileSytemService</code> gives:</p>
<pre><code class="language-shell">$ python dependency_injection.py localfs
Opening file /index.html
Opening file /index.md
Result =  ['HTML Content of file /index.html', 'Markdown Content of file /index.md']
</code></pre>
<p>Once again, <code>main</code> is still a very short <code>IO</code>, so it may be not trivial
how much the context is a life saver. But imagine the <code>main</code> <code>IO</code> to be
one of your real program. It would be much bigger, and passing the
context as global or local variables would be a much bigger problem.</p>
<h1 id="combining-a-list-of-ios"><a class="header" href="#combining-a-list-of-ios">Combining a list of IOs</a></h1>
<p>Remember that an <code>IO</code> is the description of some computation, like
a source code. As such, it can be manipulated like any value, and
so stored in lists. This section covers the operations you have
on lists of <code>IO</code>s.</p>
<h2 id="zip--from-a-list-of-io-to-an-io-of-list"><a class="header" href="#zip--from-a-list-of-io-to-an-io-of-list"><code>zip</code> : from a list of IO to an IO of list</a></h2>
<p>The <code>zip</code> function and method transform a list of <code>IO</code> into
an <code>IO</code> returning a list. Each value of the resulting list is
the value returned by the <code>IO</code> at the same location in the
input list.</p>
<p>The whole computation fails on the first failure encountered.</p>
<pre><code class="language-python">&gt;&gt;&gt; from typing import List
&gt;&gt;&gt; main : IO[None,None,List] = io.zip(io.pure(8), io.pure(&quot;Hello&quot;))
&gt;&gt;&gt; main.run(None)
Ok(success=[8, 'Hello'])
&gt;&gt;&gt; main : IO[None,str,List] = io.zip(io.pure(8), io.error(&quot;Oups&quot;))
&gt;&gt;&gt; main.run(None)
Errors(errors=['Oups'])
</code></pre>
<h2 id="sequence--running-ios-in-sequence"><a class="header" href="#sequence--running-ios-in-sequence"><code>sequence</code> : running IOs in sequence</a></h2>
<p>The function <code>io.sequence</code> is like the method <code>then</code>:
it executes a list of <code>IO</code> sequentially, returning the
value of the last <code>IO</code> and failing on the first failure
encountered:</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,int] = io.sequence(
...   io.defer(print, &quot;Hello&quot;),
...   io.defer(print, &quot;World&quot;),
...   io.pure(12)  
... )
&gt;&gt;&gt; main.run(None)
Hello
World
Ok(success=12)
</code></pre>
<h2 id="traverse--almost-like-map"><a class="header" href="#traverse--almost-like-map"><code>traverse</code> : almost like <code>map</code></a></h2>
<p>The function <code>io.traverse</code> is very much like the function <code>map</code> on lists.
Like the <code>map</code> on lists it applies a function to every element of a list.
But unlike the <code>map</code> on lists the function it applies to every element
returns an <code>IO</code>.</p>
<p><code>io.traverse</code> is useful when you need to execute a function returning
an <code>IO</code> to every element of a list. It returns an <code>IO</code> computing the
list of values returned by each call.</p>
<p>Like <code>zip</code> and <code>sequence</code>, it fails on the first failure encountered.</p>
<pre><code class="language-python">&gt;&gt;&gt; from typing import List
&gt;&gt;&gt; def add_context(i: int) -&gt; IO[int,None,int]:
...   return io.read.flat_map(lambda c:
...     io.defer(print, f&quot;context = {c}, argument = {i}&quot;)
...     .then(io.pure(c + i))
...   )
&gt;&gt;&gt; main : IO[int,None,List[int]] = io.traverse(range(10), add_context)
&gt;&gt;&gt; main.run(10)
context = 10, argument = 0
context = 10, argument = 1
context = 10, argument = 2
context = 10, argument = 3
context = 10, argument = 4
context = 10, argument = 5
context = 10, argument = 6
context = 10, argument = 7
context = 10, argument = 8
context = 10, argument = 9
Ok(success=[10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
</code></pre>
<h1 id="asynchronous-and-concurrent-programming"><a class="header" href="#asynchronous-and-concurrent-programming">Asynchronous and Concurrent Programming</a></h1>
<p>For now you know that an <code>IO</code> is very nice for stack safety,
dependency injection, failure management, and code-as-date manipulations.
There is another big feature <code>IO</code> has: simple asynchronous and
concurrent programming.</p>
<h3 id="run--the-second-and-third-argument"><a class="header" href="#run--the-second-and-third-argument"><code>run</code> : the second and third argument.</a></h3>
<p>An <code>IO</code> is executed on a pool of threads. Until now we only gave <code>io.run</code>
one argument: the context. But <code>io.run</code> accepts three arguments! The second
one is the number of threads in the pool and the third one is how long a thread
goes to sleep when idle.</p>
<p>The number of threads in the pool is fixed so you should never call a blocking
function inside one of the pool's thread. Create a new thread and run the
blocking operation inside using <code>async_</code>.</p>
<p>When one of thread has no fibers to run, it call <code>time.sleep</code> to avoid wasting
precious CPU cycles doing nothing. The third parameter of <code>run</code> is the amount of
time an idle thread sleeps (a <code>float</code> of the number of seconds to sleep). </p>
<p>Because of the infamous Python's
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">Global Interpreter Lock</a>
Python can not run thread in parallel.
So if your code only uses one 100% of a single core,
this is normal.
You know the story: Python is single-threaded.</p>
<p>To use <em>n</em> thread with an idle time of <em>idle_time</em> seconds, just give <em>n</em> and
<em>idle_time</em> to <code>io.run</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; io.pure(5).run(None, 50, 0.01)
Ok(success=5)
</code></pre>
<h2 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h2>
<p>A call to some function is called synchronous when the thread making
the call actually waits for the call to return a value. This is annoying
because the thread could be used to perform useful computations instead
of just waiting.</p>
<p>On the contrary, a call is said asynchronous when the tread making the
call does not wait for the call to finish but run useful computations
in the mean time.</p>
<p>The notorious expression <a href="http://callbackhell.com/">callback Hell</a> kindly
expresses how asynchronous programming can be error-prone, hard to write
and hard to read.</p>
<p>Asynchronous programming is all about callbacks, but fortunately,
programming models were created to hide much of its complexity under
a clean and simple interface. The famous <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>
of JavaScript is such an interface. The <a href="https://docs.python.org/3/library/asyncio-task.html">async/await</a>
syntax of many languages, including Python, is also such an interface.
So is <em>Raffiot</em>'s <code>IO</code>. But unlike the <em>async/await</em> syntax, synchronous
and asynchronous code can be transparently mixed with <code>IO</code>.</p>
<h3 id="async_--running-something-asynchronously"><a class="header" href="#async_--running-something-asynchronously"><code>async_</code> : running something asynchronously</a></h3>
<p>Calling a function <code>f</code> usually looks like this:</p>
<pre><code class="language-python">&gt;&gt;&gt; def f():
...   print(&quot;f is running&quot;)
...   return 3
&gt;&gt;&gt; def main():
...   print(&quot;f not started yet&quot;)
...   result = f()
...   print(f&quot;f finished and returned {result}&quot;)
&gt;&gt;&gt; main()
f not started yet
f is running
f finished and returned 3
</code></pre>
<p>When the function <code>main</code> calls <code>f</code>, it waits for <code>f</code> to finish.
When <code>f</code> finishes, <code>main</code> resumes its computation with the result
of <code>f</code>.</p>
<p>Asynchronous functions, like
<a href="https://docs.python.org/fr/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async">apply_async</a>
do not work this way.
Calling an <em>asynchronous</em> function <code>fasync</code> usually looks like this.</p>
<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; from multiprocessing import Pool
&gt;&gt;&gt;
&gt;&gt;&gt; def f():
...  print(&quot;f is running&quot;)
...  return 3
&gt;&gt;&gt;
&gt;&gt;&gt; with Pool(4) as pool: 
...   def fasync(callback):
...     pool.apply_async(f, callback = callback)
...   
...   def main():
...     print(&quot;fasync not started yet&quot;)
...   
...     def callback(result):
...       print(f&quot;fasync finished and returned {result}&quot;)
...     
...     fasync(callback)
...     print(&quot;fasync started&quot;)
...    
...   main()
...   time.sleep(0.5)
fasync not started yet
fasync started
f is running
fasync finished and returned 3
</code></pre>
<p>As you can seen, the function <code>main</code> does not wait that <code>f</code> finishes
but continues its execution printing <code>fasync started</code>.
The function <code>main</code> can not get the result of <code>f</code> so it defines
a function, called a <strong>callback</strong>, to process the result of when it
finishes.</p>
<p>With <em>Raffiot</em>'s <code>IO</code> you would write:</p>
<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; from multiprocessing import Pool
&gt;&gt;&gt; from raffiot import *
&gt;&gt;&gt;   
&gt;&gt;&gt; def f():
...   print(&quot;f is running&quot;)
...   return 3
&gt;&gt;&gt;  
&gt;&gt;&gt; with Pool(4) as pool: 
...   f_io : IO[None,None,int] = (
...     io.async_(
...       lambda r, k:
...         pool.apply_async(f, callback = lambda r: k(Ok(r)))
...     )
...   )
... 
...   main : IO[None,None,None] = io.sequence(
...     io.defer(print, &quot;fasync not started yet&quot;),
...     f_io.flat_map(lambda result:
...       io.defer(print, f&quot;fasync finished and returned {result}&quot;)
...     ),
...     io.defer(print, &quot;fasync started&quot;)
...   )
... 
...   main.run(None)
fasync not started yet
f is running
fasync finished and returned 3
fasync started
</code></pre>
<h2 id="concurrent-programming"><a class="header" href="#concurrent-programming">Concurrent Programming</a></h2>
<p>Concurrent programming is about running things &quot;in parallel&quot;. <em>Raffiot</em> can run
a large number of concurrent computation simply and safely:</p>
<h3 id="parallel--running-concurrent-tasks"><a class="header" href="#parallel--running-concurrent-tasks"><code>parallel</code> : running concurrent tasks</a></h3>
<p>The function <code>io.parallel</code> runs a list of <code>IO</code>s in parallel.
Remember that because of Python's
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">Global Interpreter Lock</a>
only one thread executing Python's code can be running
at any time. But your code involves a lot of primitives
written in <em>C</em>/<em>C++</em>/etc, then you might get lucky and
use all of your cores.</p>
<p><code>parallel</code> returns a list of values called <strong>fibers</strong>.
A <em>fiber</em> represents a tasks running in parallel/concurrently.
Every <em>fiber</em> in the returned list correspond to the
<code>IO</code> at the same location in the argument list.
For example in</p>
<pre><code class="language-python">io.parallel(ios).flat_map(lambda fibers: ...)
</code></pre>
<p>for every index <code>i</code>, <code>fibers[i]</code> is the fiber representing
the computation of the <em>IO</em> <code>ios[i]</code> running in parallel/concurrently.</p>
<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; def task(i: int) -&gt; IO[None,None,None] :
&gt;&gt;&gt;   return io.defer(print, f&quot;Task {i}: Begin&quot;).then(
...     io.defer(time.sleep, 1),
...     io.defer(print, f&quot;Task {i}: End&quot;)
...   )
&gt;&gt;&gt; main : IO[None,None,None] = (
...   io.parallel([task(i) for i in range(6)])
...   .then(io.defer(print,&quot;Finished&quot;)))
&gt;&gt;&gt; main.run(None)
Task 0: Begin
Task 1: Begin
Task 3: Begin
Task 4: Begin
Task 2: Begin
Finished
Task 5: Begin
Task 0: End
Task 1: End
Task 3: End
Task 4: End
Task 2: End
Task 5: End
Ok(success=None)
</code></pre>
<p>As you can see, <code>main</code> does not wait for the <code>IO</code>s running
in parallel/concurrently to continue its execution.</p>
<h3 id="wait--waiting-for-concurrent-tasks-to-end"><a class="header" href="#wait--waiting-for-concurrent-tasks-to-end"><code>wait</code> : waiting for concurrent tasks to end</a></h3>
<p>Sometimes you want to wait for a parallel/concurrent computation
to finish. Remember that parallel/concurrent computation are
represented by the <em>fibers</em> returned by <code>io.parallel</code>.</p>
<p>To wait for some fibers to finish, just call <code>io.wait</code> with
the list of fibers you want to wait on. The result of <code>wait</code>
is the list of all the fibers results (of type <code>Result[E,A]</code>).
For example, in</p>
<pre><code class="language-python">io.wait(fibers).flat_map(lambda results: ...)
</code></pre>
<p>for any index <code>i</code>, <code>result[i]</code> of type <code>Result[E,A]</code> is the result
of the computation represented by the fiber <code>fibers[i]</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,None] = (
...   io.parallel([task(i) for i in range(6)])
...   .flat_map(lambda fibers: io.wait(fibers))
...   .then(io.defer(print,&quot;Finished&quot;)))
&gt;&gt;&gt; main.run(None)
Task 0: Begin
Task 1: Begin
Task 3: Begin
Task 5: Begin
Task 4: Begin
Task 2: Begin
Task 0: End
Task 3: End
Task 1: End
Task 5: End
Task 4: End
Task 2: End
Finished
Ok(success=None)
</code></pre>
<h3 id="yield_--letting-other-task-progress"><a class="header" href="#yield_--letting-other-task-progress"><code>yield_</code> : letting other task progress</a></h3>
<p>Remember that an <code>IO</code> runs on a pool of thread.
There there is more <code>IO</code>s to run than the number of threads to run on,
there is a chance that some <code>IO</code> will not get executed.
An <code>IO</code> can explicitly release its thread for a moment to let other
tasks a chance to progress.</p>
<p>Call <code>io.yield_</code> to release the current thread. The <code>IO</code> will make
a break and continue its execution later.</p>
<pre><code class="language-python">&gt;&gt;&gt; main : IO[None,None,None] = io.defer(print, &quot;Hello&quot;).then(
...   io.yield_,
...   io.defer(print, &quot;World!&quot;) 
... )
&gt;&gt;&gt; main.run(None)
Hello
World!
Ok(success=None)
</code></pre>
<h2 id="controlling-concurrency"><a class="header" href="#controlling-concurrency">Controlling Concurrency</a></h2>
<p>Sometimes you want to prevent some fibers to run concurrently. For example you
may want to avoid several fibers modifying variables at the same time or
avoiding too many fibers to access some resources.</p>
<h3 id="reentrant_lock-only-one-fiber-at-a-time"><a class="header" href="#reentrant_lock-only-one-fiber-at-a-time"><code>reentrant_lock</code>: only one fiber at a time.</a></h3>
<p>The primitive <code>resource.reentrant_lock</code> ensures that <strong>only one</strong> fiber can run
a portion of code <strong>at a time</strong>:</p>
<pre><code class="language-python">resource.reentrant_lock: IO[Any, None, Resource[Any, None, None]]
</code></pre>
<p>Let's take an example. The class <code>Shared</code> represents any class defining mutable
objects. In our example, calling the <code>set</code> method change the object's attribute
<code>value</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from raffiot import *
&gt;&gt;&gt; from typing import Any
&gt;&gt;&gt;  
&gt;&gt;&gt; class Shared:
...     def __init__(self):
...         self._value = 0
...  
...     def get(self) -&gt; int:
...         return self._value
...  
...     def set(self, i: int) -&gt; None:
...         self._value = i
&gt;&gt;&gt;  
&gt;&gt;&gt; shared_object = Shared()
</code></pre>
<p>The <code>increment</code> <em>IO</em> does exactly as its name suggests: it reads the shared
object attribute <code>value</code> using the method <code>get</code>, wait for one second and
set the attribute with <code>value + 1</code> using the <code>set</code> method:</p>
<pre><code class="language-python">&gt;&gt;&gt; increment: IO[Any,None,None] = (
...   io.defer(shared_object.get)
...     .flat_map(lambda value:
...       io.sleep(1)
...         .then(io.defer(shared_object.set, value + 1))
...     )
... )
&gt;&gt;&gt; shared_object.get()
0
&gt;&gt;&gt; increment.run(None)
Ok(success=None)
&gt;&gt;&gt; shared_object.get()
1
</code></pre>
<p>Running <code>increment</code> several times concurrently is unsafe:</p>
<pre><code class="language-python">&gt;&gt;&gt; shared_object.get()
1
&gt;&gt;&gt; io.parallel(increment, increment).run(None)
Ok(success=...)
&gt;&gt;&gt; shared_object.get()
2
</code></pre>
<p>Although the <code>value</code> was <em>1</em> and <code>increment</code> has been called twice, its final
value is <em>2</em> instead of the expected <em>3</em>. The reason if the issue is they both
have read the value <em>1</em> at the same time, and so both written <code>value + 1 == 2</code>
instead of <em>3</em>. We need to prevent one instance of <code>increment</code> to run if
another one is already running. We can do so using <code>reentrant_lock</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; shared_object.get()
2
&gt;&gt;&gt; resource.reentrant_lock.flat_map(lambda lock:
...   io.parallel(
...     lock.with_(increment),
...     lock.with_(increment)
...   )
&gt;&gt;&gt; ).run(None)
Ok(success=[...])
&gt;&gt;&gt; shared_object.get()
4
</code></pre>
<p><code>reentrant_lock</code> gives us a <code>lock</code> which is a <code>Resource</code>. The two instances
of <code>increment</code> still runs in parallel, but inside a <code>lock.with_(an_io)</code> which
prevent them from running at the same time. The first instance to take the lock
forces the second one to wait it releases it.</p>
<p>You will learn more about <code>Resource</code> in the section
<a href="./resources.html">Resource Management</a>, but for now just remember that you can
prevent some fibers to run concurrently by creating a lock with <code>reentrant_lock</code>
and using <code>lock.with_</code> to wrap portion of the code you want to avoid being
accessed concurrently. The type <code>Resource</code> is used to ensure that the lock will
always be released, even if the computation fails.</p>
<p>Note: every call to <code>reentrant_lock</code> gives back a different lock.</p>
<p>Unlike the python equivalent
<a href="https://docs.python.org/3/library/threading.html#lock-objects"><code>threading.Lock</code></a>,
<em>Raffiot</em>'s locks do not block threads, they only block fibers.</p>
<p>In addition, the these locks are <strong>reentrant</strong>, which means that the fiber that
have the lock can still acquire it without blocking.</p>
<h3 id="semaphore-limited-resource"><a class="header" href="#semaphore-limited-resource"><code>semaphore</code>: limited resource.</a></h3>
<p>The primitive <code>resource.semaphore</code> is useful to simulate limited resources.</p>
<p>Imagine you have to call an API for which it is forbidden to make more than
<em>n</em> concurrent calls, <code>semaphore</code> is the way to go:</p>
<pre><code class="language-python">resource.semaphote(tokens: int): IO[Any, None, Resource[Any, None, None]]
</code></pre>
<p>The parameter <code>tokens</code> is the number of fibers the semaphore will allow to run
concurrently:</p>
<pre><code class="language-python">&gt;&gt;&gt; from raffiot import *
&gt;&gt;&gt; from typing import Any
&gt;&gt;&gt;  
&gt;&gt;&gt; def fiber(sem, i:int) -&gt; IO[Any, None, None]:
...   return sem.with_(io.defer(print, f&quot;Fiber {i} running!&quot;))
&gt;&gt;&gt;  
&gt;&gt;&gt; resource.semaphore(5).flat_map(lambda sem:
...   io.parallel([fiber(sem, i) for i in range(100)])
... ).run(None)
</code></pre>
<p>Even though there are 100 fibers running concurrently, there will be only 5
concurrent calls to <code>print</code>.</p>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>Time functions enable you to schedule some computations in the future or to
stop a fiber until a point in time is reached.</p>
<h3 id="sleep-making-a-break"><a class="header" href="#sleep-making-a-break"><code>sleep</code>: making a break</a></h3>
<p>To pause an <code>IO</code> for some time, just call <code>io.sleep</code> with the number of seconds
you want the <code>IO</code> paused:</p>
<pre><code class="language-python">&gt;&gt;&gt; from time import time
&gt;&gt;&gt; now : IO[None, None, None] = io.defer(time).flat_map(lambda t: io.defer(print, t))
&gt;&gt;&gt; main : IO[None, None, None] = now.then(io.sleep(2), now)
&gt;&gt;&gt; main.run(None)
1615136436.7838593
1615136438.785897
Ok(success=None)
</code></pre>
<p>Calling <code>io.sleep(0)</code> does nothing. The <code>IO</code> is guaranteed to be paused for at
least the time you requested, but it may sleep longer! Especially when threads
are busy.</p>
<h3 id="sleep_until-waking-up-in-the-future"><a class="header" href="#sleep_until-waking-up-in-the-future"><code>sleep_until</code>: waking up in the future.</a></h3>
<p>To pause an <code>IO</code> until some determined time in the future, call <code>io.sleep_until</code>
with the desired epoch:</p>
<pre><code class="language-python">&gt;&gt;&gt; from time import time
&gt;&gt;&gt; now : IO[None, None, None] = io.defer(time).flat_map(lambda t: io.defer(print, t))
&gt;&gt;&gt; time()
1615136688.9909387
&gt;&gt;&gt; main : IO[None, None, None] = now.then(io.sleep_until(1615136788), now)
&gt;&gt;&gt; main.run(None)
1615136713.6873975
1615136788.0037072
Ok(success=None)
</code></pre>
<p>Calling <code>io.sleep_until</code> with an epoch in the past does nothing.
The <code>IO</code> is guaranteed to be paused until the epoch you requested is reached but
it can sleep longer! Especially when threads are busy.</p>
<h1 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h1>
<p>Resource management is the safe creation and release
of resources: files, connection handlers, etc. Resource
management ensures all created resources will be released
this avoiding resource leaks.</p>
<p>Consider the code below accessing a database:</p>
<pre><code class="language-python">&gt;&gt;&gt; connection = connect_to_database()
&gt;&gt;&gt; connection.exectute_sql_query(...)
&gt;&gt;&gt; connection.close()
</code></pre>
<p>If the execution of the SQL query raise an exception, the
connection is never closed. Having too many unused connection
opened may forbid other parts of the code from creating new
connections, or may slow down the database or even crash
the application.</p>
<p>Fortunately Python has a built-in support for resource management
with the <code>with</code> syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; with connect_to_database() as connection:
...   connection.exectute_sql_query(...)
</code></pre>
<p>Sometimes the resource you want to create depends on another resource.
For example the connection configuration to the database could be
stored in a configuration file that need to be opened and closed:</p>
<pre><code class="language-python">&gt;&gt;&gt; with open_config_file() as file_content:
...   config = read_config(file_content)
...   with connect_to_database(config) as connection:
...     connection.exectute_sql_query(...)
</code></pre>
<p>Once again Python's <code>with</code>-statement covers this case nicely.
But there are two issues with Python's built-in resource management:</p>
<ol>
<li>it is not trivial to pack two dependent resources into one.</li>
<li>it is not trivial to create your own resources.</li>
</ol>
<p>This is where <em>Raffiot</em>'s resource management comes in.
Creating a <code>Resource</code> is as simple as providing a function to create
the resource and one to release it. You can also lift any Python's
&quot;<code>with</code>-enabled&quot; resource to <em>Raffiot</em>'s <code>Resource</code> by a single
function call.</p>
<p><code>Resource</code> do compose very well too with the same API as <code>IO</code>.
In fact <code>Resource</code> is built upon <code>IO</code>. It has almost all of its
functionalities. Here are the imports for this section:</p>
<pre><code class="language-python">&gt;&gt;&gt; from raffiot import *
&gt;&gt;&gt; from typing import Tuple, List, Any
</code></pre>
<p>Let's start by defining an <code>IO</code> that generates a random string
every time it runs:</p>
<pre><code class="language-python">&gt;&gt;&gt; import random
&gt;&gt;&gt; import string
&gt;&gt;&gt; rnd_str : IO[None, None, str] = (
...   io.defer(lambda:
...     ''.join(
...       random.choice(string.ascii_uppercase + string.digits)
...      for _ in range(8)
...     )
...   )
... )
&gt;&gt;&gt; rnd_str.run(None)
Ok(success='CCQN80YY')
&gt;&gt;&gt; rnd_str.run(None)
Ok(success='5JEOGVZS')
&gt;&gt;&gt; rnd_str.run(None)
Ok(success='ZNLWSH1B')
&gt;&gt;&gt; rnd_str.run(None)
Ok(success='MENS91RD')
</code></pre>
<h2 id="from_open_close_io--creating-a-resource-from-openclose-ios"><a class="header" href="#from_open_close_io--creating-a-resource-from-openclose-ios"><code>from_open_close_io</code> : Creating a <code>Resource</code> from open/close <code>IO</code>s</a></h2>
<p>The <code>Resource</code> we want to define will create and print a new string
every time it is used. Releasing it will simply be printing it.
A <code>Resource</code> is essentially two computations:</p>
<ul>
<li>one creating the resource</li>
<li>one releasing the resource</li>
</ul>
<p>Let's start by the <code>IO</code> creating and printing the string:</p>
<pre><code class="language-python">&gt;&gt;&gt; rs_open : IO[None, None, str] = (
...   rnd_str.flat_map(lambda s: io.sequence(
...     io.defer(print, f&quot;Opening {s}&quot;),
...     io.pure(s)
...   ))
... )
</code></pre>
<p>Now the function releasing the string (i.e. printing it):</p>
<pre><code class="language-python">&gt;&gt;&gt; def rs_close(s: str, cs: ComputationStatus) -&gt; IO[None, None, None]:
...   return io.defer(print, f&quot;Closing {s}&quot;)
</code></pre>
<p>The first function argument is the created resource. The second one indicates
whether the computation was successful. It can be either
<code>ComputationStatus.SUCCEEDED</code> or <code>ComputationStatus.FAILED</code>.</p>
<p>From there, creating a <code>Resource</code> is as simple as a single call
to <code>resource.from_open_close_io</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; rs : Resource[None,None,str] = resource.from_open_close_io(rs_open, rs_close)
</code></pre>
<p>That wasn't that hard, isn't it?</p>
<h2 id="use--using-a-resource"><a class="header" href="#use--using-a-resource"><code>use</code> : using a resource</a></h2>
<p>Now that we have a <code>Resource</code>, we want to use it. To do so, just
call the method <code>use</code>. You need to give it a function taking as
argument the resource created and retuning an <code>IO</code> that used this
resource. The result is an <code>IO</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; io_ok : IO[None,None,int] = rs.use(lambda s: io.pure(5))
&gt;&gt;&gt; io_ok.run(None)
Opening B9G0G96J
Closing B9G0G96J
Ok(success=5)
</code></pre>
<p>As you can see a random string is created and released.
The result is an <code>IO</code> whose result is the result of the inner <code>IO</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; io_error : IO[None,None,Any] = rs.use(lambda s: io.error(&quot;Oups!&quot;))
&gt;&gt;&gt; io_error.run(None)
Opening R9A1YSJ3
Closing R9A1YSJ3
Error(error='Oups!')
</code></pre>
<p>If the inner <code>IO</code> fails, the string is still released!</p>
<pre><code class="language-python">&gt;&gt;&gt; io_panic : IO[None,None,None] = rs.use(lambda s: io.panic(Exception(&quot;BOOM!&quot;)))
&gt;&gt;&gt; io_panic.run(None)
Opening PSUNW6M5
Closing PSUNW6M5
Panic(exception=Exception('BOOM!'))
</code></pre>
<p>If the inner <code>IO</code> panics, the string is still released too!</p>
<p>Note: the <code>with_(an_io)</code> method is a nice alias for <code>use(lambda _: an_io)</code>.</p>
<h2 id="map-flat_map-defer-async_-and-others"><a class="header" href="#map-flat_map-defer-async_-and-others"><code>map</code>, <code>flat_map</code>, <code>defer</code>, <code>async_</code> and others.</a></h2>
<p><code>Resource</code> supports almost the same API as <code>IO</code>.
It includes <code>map</code>, <code>flat_map</code>, <code>defer</code>, <code>zip</code>, etc.
It means, for example, that you can create resources in parallel,
or simply create a list of resources (if one fails, all fails),
etc.</p>
<h2 id="lift_io--from-io-to-resource"><a class="header" href="#lift_io--from-io-to-resource"><code>lift_io</code> : from <code>IO</code> to <code>Resource</code></a></h2>
<p>Actually, any <code>IO[E,E,A]</code> can be lifted into a <code>Resource[R,E,A]</code>.
The releasing function is just a no-op. It brings a lot of expressiveness
and safety to resource creation:</p>
<pre><code class="language-python">&gt;&gt;&gt; rs : Resource[None,None,None] = resource.lift_io(io.defer(print, &quot;Hello World!&quot;))
&gt;&gt;&gt; rs.use(lambda none: io.pure(5)).run(None)
Hello World!
Ok(success=5)
</code></pre>
<h2 id="from_open_close--resource-from-open-and-close-functions"><a class="header" href="#from_open_close--resource-from-open-and-close-functions"><code>from_open_close</code> : Resource from open and close functions</a></h2>
<p>Sometimes it is easier to create a <code>Resource</code> from usual Python's
functions rather than from the open/close <code>IO</code>s. To do so, just
use the function <code>resource.from_open_close</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; def rs_open() -&gt; str:
...   s = ''.join(
...     random.choice(string.ascii_uppercase + string.digits)
...     for _ in range(8)
...   )
...   print(f&quot;Opening {s}&quot;)
...   return s
&gt;&gt;&gt; def rs_close(s: str, cs: ComputationStatus) -&gt; None:
...   print(f&quot;Closing {s}&quot;)
&gt;&gt;&gt; rs : Resource[None,None,str] = resource.from_open_close(rs_open, rs_close)
</code></pre>
<p>Once again, the he first argument of <code>rs_close</code> is the created resource and
the second one indicates whether the computation was successful:
<code>ComputationStatus.SUCCEEDED</code> or <code>ComputationStatus.FAILED</code>.</p>
<h2 id="from_with--resource-from-with"><a class="header" href="#from_with--resource-from-with"><code>from_with</code> : Resource from <code>with</code></a></h2>
<p>If the resource you want to create already support Python's
<code>with</code>-statement, then you're lucky: you just have to make
one single call to <code>resource.from_with</code></p>
<pre><code class="language-python">&gt;&gt;&gt; rs : Resource[None,None,str] = resource.from_with(io.defer(open, &quot;hello.txt&quot;, &quot;w&quot;))
</code></pre>
<h2 id="creating-a-resource-directly"><a class="header" href="#creating-a-resource-directly">Creating a Resource directly</a></h2>
<p>A <code>Resource[R,E,A]</code> is essentially an
<code>IO[R,E,Tuple[A, Callable[[ComputationStatus], IO[R,E,Any]]]]</code>.
When the <code>IO</code> runs, it returns a pair
<code>Tuple[A, Callable[[ComputationStatus], IO[R,Any,Any]]]</code>.
The fist member of the pair is the created resource of type <code>A</code>.
The second member of the pair is the release function. Its argument is a
<code>ComputationStatus</code> indicating whether the computation was successful.
It must return an <code>IO</code> that perform the release of the resource.</p>
<p>Note that any failure encountered when releasing the resource makes the <code>IO</code>
to fail too.</p>
<pre><code class="language-python">&gt;&gt;&gt; create : IO[None,None,Tuple[str, IO[None,Any,Any]]] = (
...   rnd_str.flat_map(lambda filename:
...     io.defer(print, f&quot;Opening {filename}&quot;).map(lambda file:
...       (file, lambda computationStatus: io.defer(print, f&quot;Closing {filename}&quot;))
...     )
...   )
... )
&gt;&gt;&gt; rs : Resource[None,None,str] = Resource(create)
</code></pre>
<h2 id="use-case--temporary-file"><a class="header" href="#use-case--temporary-file">Use Case : Temporary File</a></h2>
<p>This is a complete use case of a <code>Resource</code> creating a random file.</p>
<pre><code class="language-python">&gt;&gt;&gt; from io import TextIOWrapper
&gt;&gt;&gt; create : IO[None,None,Tuple[TextIOWrapper, IO[None,None,None]]] = (
...   rnd_str
...   .flat_map(lambda filename:
...     io.defer(print, f&quot;Opening {filename}&quot;)
...     .then(io.defer(open, filename, &quot;w&quot;))
...     .map(lambda file:
...       ( file,
...         lambda computationStatus: io.defer(print, f&quot;Closing {filename}&quot;)
...         .then(io.defer(file.close))
...       )
...     )
...    )
... )
&gt;&gt;&gt; rs : Resource[None,None,TextIOWrapper] = Resource(create)
&gt;&gt;&gt; io_ok : IO[None,None,None] = (
...   rs.use(lambda file:
...     io.defer(file.write, &quot;Hello World!&quot;)
...   )
... )
&gt;&gt;&gt; io_ok.run(None)
Opening 6E21M413
Closing 6E21M413
Ok(success=12)
&gt;&gt;&gt; io_error : IO[None,None,None] = (
...   rs.use(lambda file:
...     io.defer(file.write, &quot;Hello World!&quot;)
...     .then(io.error(&quot;Oups!&quot;))
...   )
... )
&gt;&gt;&gt; io_error.run(None)
Opening R9A1YSJ3
Closing R9A1YSJ3
Errors(errors=['Oups!'])
&gt;&gt;&gt; io_panic : IO[None,None,None] = (
...   rs.use(lambda file:
...     io.defer(file.write, &quot;Hello World!&quot;)
...     .then(io.panic(Exception(&quot;BOOM!&quot;)))
...   )
... )
&gt;&gt;&gt; io_panic.run(None)
Opening R1V3A0SO
Closing R1V3A0SO
Panic(exceptions=[Exception('BOOM!')], errors=[])
</code></pre>
<h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p><code>IO</code> is heavily expression based but <em>Python</em> does not allow to define local
variables in expressions. <em>Raffiot</em> provides two types to work around this
limitation: <code>Val</code> and <code>Var</code>. A <code>Val</code> is an immutable variable while a <code>Var</code> is
a mutable variable.</p>
<h2 id="immutable-variables"><a class="header" href="#immutable-variables">Immutable Variables</a></h2>
<p>Immutable variables can be created very easily by using the class <code>Val</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from raffiot import *
&gt;&gt;&gt; Val(5)
Val(value=5)
</code></pre>
<p><code>Val</code> has most of the usual operations like <code>map</code>, <code>flat_map</code>, <code>zip</code>, etc.
Please have a look the the <a href="./api/index.html">API</a> for a complete list of
methods.</p>
<p>For example, Python's forbids this syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; lambda x:
&gt;&gt;&gt;   y = x + 5
&gt;&gt;&gt;   print(f&quot;y={y}&quot;)
</code></pre>
<p>because it only allows lambdas to contain one single expression.
To simulate this behaviour, you can use:</p>
<pre><code class="language-python">&gt;&gt;&gt; lambda x: Val(x+5).map(lambda y: print(f&quot;y={y}&quot;))
</code></pre>
<p>We totally agree that the first syntax is far superior, but until Python allows
lambda to declare local variables, this is probably the best we can get.</p>
<h2 id="mutable-variables"><a class="header" href="#mutable-variables">Mutable Variables</a></h2>
<p><em>Raffiot</em>'s mutable variable are not only mutable variables. They are designed
to play nicely with concurrency. <strong>Every access to the a <code>Var</code> is exclusive</strong>,
which means only one fiber is allowed to read or modify the variable at any
time.</p>
<h3 id="varcreate-varcreate_rs-the-only-ways-to-create-a-mutable-variable"><a class="header" href="#varcreate-varcreate_rs-the-only-ways-to-create-a-mutable-variable"><code>Var.create</code>, <code>Var.create_rs</code>: the only ways to create a mutable variable</a></h3>
<p>Because a <code>Var</code> is not just a value, it can only be created either by the <em>IO</em>
<code>Var.create(a:A)</code> of type <code>IO[Any,None,Var[A]]</code> or the <em>Resource</em>
<code>Var.create(a:A)</code> of type <code>Resource[Any,None,Var[A]]</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from typing import Any
&gt;&gt;&gt; main: IO[Any,None,None] = (
...   Var.create(5).flat_map(lambda var1: var1.set(7).then(var1.get()))
... )
&gt;&gt;&gt; main.run(None)
Ok(success=7)
&gt;&gt;&gt; main_rs: Resource[Any,None,None] = (
...   Var.create_rs(5).flat_map(lambda var1: var1.set_rs(7).then(var1.get_rs()))
... )
&gt;&gt;&gt; main_rs.use(io.pure).run(None)
Ok(success=7)
</code></pre>
<p>As you can see, you can use the methods <code>get</code>/<code>set</code> to get/set the current value
as an <code>IO</code> or <code>get_rs</code>/<code>set_rs</code> to get/set the current value as a <code>Resource</code>.</p>
<p>Alternatively, you can use the method <code>get_and_set</code> and <code>get_and_set_rs</code> to
assign a new value to the variable and get the previous value at the same time.</p>
<h3 id="update-modifying-the-current-value"><a class="header" href="#update-modifying-the-current-value"><code>update</code>: modifying the current value</a></h3>
<p>When you need to update the current value of a variable <code>var:Var[A]</code>, use the
<code>update</code> method.
It takes as input a function <code>f: Callable[[A], Tuple[A,B]]</code>. This function will
receive the current value of the variable and must return a pair
<code>(new_value, returned)</code>. The <code>new_value</code> will become the new value of the
variable. The value <code>returned</code> serves to output some value if you want to.</p>
<pre><code class="language-python">&gt;&gt;&gt; main: IO[Any,None,None] = (
...   Var.create(5).flat_map(lambda v: v.update(lambda x: (x+1, 2*x)))
... )
&gt;&gt;&gt; main.run(None)
Ok(success=UpdateResult(old_value=5, new_value=6, returned=10))
</code></pre>
<p>The functions <code>update_io</code> and <code>update_rs</code> are respectively for <em>IO</em> and
<em>Resource</em> functions.</p>
<h3 id="traverse-creating-a-new-variable-from-another-one"><a class="header" href="#traverse-creating-a-new-variable-from-another-one"><code>traverse</code>: creating a new variable from another one.</a></h3>
<p>The <code>traverse</code> methods create a new variable using an existing one:</p>
<pre><code class="language-python">&gt;&gt;&gt; main: IO[Any,None,None] = (
...   Var.create(5)
...      .flat_map(lambda var1: var1.traverse(lambda x: io.defer(print, x)
...                                                       .then(io.pure(x+1))
...                                          )
...                                  .flat_map(lambda var2: var2.get())
...       )
... )
5
Ok(success=6)
</code></pre>
<h3 id="zip-getting-the-values-of-a-group-of-variables"><a class="header" href="#zip-getting-the-values-of-a-group-of-variables"><code>zip</code>: Getting the values of a group of variables</a></h3>
<p>The <code>zip</code> class method regroup the values a list of variable. All concurrent
access to the variables are forbidden during the zip to ensure consistent
reading of the variables values:*</p>
<pre><code class="language-python">&gt;&gt;&gt; main: IO[Any,None,None] = (
...   io.zip(Var.create(0), Var.create(1))
...     .flat_map(lambda vars:
...       Var.zip(vars[0], vars[1])
...     )
... )
&gt;&gt;&gt; main.run(None)
Ok(success=[0, 1])
</code></pre>
<p>Note: the <code>zip_with</code> instance method is equivalent.</p>
<h3 id="ap-combining-the-values-of-a-group-of-variables"><a class="header" href="#ap-combining-the-values-of-a-group-of-variables"><code>ap</code>: Combining the values of a group of variables</a></h3>
<p>The <code>zip</code> class method regroup the values a list of variable. All concurrent
access to the variables are forbidden during the zip to ensure consistent
reading of the variables values:*</p>
<pre><code class="language-python">&gt;&gt;&gt; main: IO[Any,None,None] = (
...   Var.create(lambda x, y: x + y)
...      .flat_map(lambda var_fun:
...         io.zip(Var.create(2), Var.create(3))
...           .flat_map(lambda vars:
...             var_fun.ap(vars[0], vars[1])
...           )
...     )
... )
&gt;&gt;&gt; main.run(None)
Ok(success=5)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
