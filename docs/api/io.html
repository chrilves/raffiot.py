<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>raffiot.io API documentation</title>
<meta name="description" content="Data structure representing a computation." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>raffiot.io</code></h1>
</header>
<section id="section-intro">
<p>Data structure representing a computation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Data structure representing a computation.
&#34;&#34;&#34;

from __future__ import annotations

import time
from collections import abc
from typing import TypeVar, Generic, Callable, Any, List, Iterable, Union

from typing_extensions import final

from raffiot._internal import IOTag
from raffiot.result import Result, Ok, Errors, Panic
from raffiot.utils import MatchError
from raffiot import result

__all__ = [
    &#34;Fiber&#34;,
    &#34;IO&#34;,
    &#34;pure&#34;,
    &#34;defer&#34;,
    &#34;defer_io&#34;,
    &#34;read&#34;,
    &#34;error&#34;,
    &#34;errors&#34;,
    &#34;panic&#34;,
    &#34;from_result&#34;,
    &#34;zip&#34;,
    &#34;sequence&#34;,
    &#34;yield_&#34;,
    &#34;async_&#34;,
    &#34;defer_read&#34;,
    &#34;defer_read_io&#34;,
    &#34;traverse&#34;,
    &#34;parallel&#34;,
    &#34;wait&#34;,
    &#34;zip_par&#34;,
    &#34;sleep_until&#34;,
    &#34;sleep&#34;,
    &#34;rec&#34;,
    &#34;safe&#34;,
]


R = TypeVar(&#34;R&#34;)
E = TypeVar(&#34;E&#34;)
A = TypeVar(&#34;A&#34;)
X = TypeVar(&#34;X&#34;)
R2 = TypeVar(&#34;R2&#34;)
E2 = TypeVar(&#34;E2&#34;)
A2 = TypeVar(&#34;A2&#34;)


@final
class Fiber(Generic[R, E, A]):
    pass


@final
class IO(Generic[R, E, A]):
    &#34;&#34;&#34;
    Represent a computation that computes a value of type A,
    may fail with an errors (expected failure) of type E and have access
    anytime to a read-only context of type R.

    /!\\ **VERY IMPORTANT** /!\\

    1. **DO NEVER SUB-CLASS IO**: it would break the API.
    2. **DO NEVER INSTANTIATE an IO DIRECTLY**: use **only** the functions
       ands methods in this module.
    3. The IO is **LAZY**:
        no code is run until you invoke the run method.
    4. The IO never raises exceptions (unless there is a bug):
        it returns panics instead.
    5. The IO is stack-safe, but you need to make sure your own code is too!
        use defer and defer_io to avoid stack-overflow.

    Have a look to the documentation and examples to learn how to use it.
    &#34;&#34;&#34;

    __slots__ = &#34;__tag&#34;, &#34;__fields&#34;

    def __init__(self, __tag, __fields):
        self.__tag = __tag
        self.__fields = __fields

    def map(self, f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Transform the computed value with f if the computation is successful.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return IO(IOTag.MAP, (self, f))

    def flat_map(self, f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) can be used in the second (f).
        &#34;&#34;&#34;
        return IO(IOTag.FLATMAP, (self, f))

    def then(self, *others: IO[R, E, A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) is dropped.
        &#34;&#34;&#34;
        if len(others) == 1 and isinstance(others[0], abc.Iterable):
            return IO(IOTag.SEQUENCE, list((self, *others[0])))
        return IO(IOTag.SEQUENCE, list((self, *others)))

    def zip(self: IO[R, E, A], *others: IO[R, E, X]) -&gt; IO[R, E, Iterable[A]]:
        &#34;&#34;&#34;
        Pack a list of IO (including self) into an IO computing the list
        of all values.

        If one IO fails, the whole computation fails.
        &#34;&#34;&#34;
        if len(others) == 1 and isinstance(others[0], abc.Iterable):
            return IO(IOTag.ZIP, list((self, *others[0])))
        return IO(IOTag.ZIP, list((self, *others)))

    def zip_par(self: IO[R, E, A], *others: IO[R, E, A]) -&gt; IO[R, E, List[A]]:
        &#34;&#34;&#34;
        Pack a list of IO (including self) into an IO computing the list
        of all values in parallel.

        If one IO fails, the whole computation fails.
        &#34;&#34;&#34;
        return zip_par(self, *others)

    def parallel(self: IO[R, E, A], *others: IO[R, E, A]) -&gt; IO[R, E, List[Fiber]]:
        &#34;&#34;&#34;
        Run all these IO (including self) in parallel.
        Return the list of fibers, in the same order.

        Each Fiber represent a parallel computation. Call

        &gt;&gt;&gt; wait([fiber1, fiber2, ...])

        to wait until the computations of fiber1, fiber2, etc are done.
        :param l: the list of IO to run in parallel.
        :return: the same list where each IO has been replaced by its Fiber
        &#34;&#34;&#34;
        if len(others) == 1 and isinstance(others[0], abc.Iterable):
            return IO(IOTag.PARALLEL, list((self, *others[0])))
        return IO(IOTag.PARALLEL, list((self, *others)))

    def flatten(self):
        &#34;&#34;&#34;
        Concatenation function on IO
        &#34;&#34;&#34;
        if self.__tag == 0:
            return self.__fields
        return IO(IOTag.FLATTEN, self)

    # Reader API

    def contra_map_read(self, f: Callable[[R2], R]) -&gt; IO[R2, E, A]:
        &#34;&#34;&#34;
        Transform the context with f.
        Note that f is not from R to R2 but from R2 to R!
        &#34;&#34;&#34;
        return IO(IOTag.CONTRA_MAP_READ, (f, self))

    # Errors API

    def catch(self, handler: Callable[[List[E]], IO[R, E, A]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to errors (the except part of a try-except).

        On errors, call the handler with the errors.
        &#34;&#34;&#34;
        return IO(IOTag.CATCH, (self, handler))

    def map_error(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
        &#34;&#34;&#34;
        Transform the stored errors if the computation fails on an errors.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return IO(IOTag.MAP_ERROR, (self, f))

    # Panic

    def recover(
        self, handler: Callable[[List[Exception], List[E]], IO[R, E, A]]
    ) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to panics (the except part of a try-except).

        On panic, call the handler with the exceptions.
        &#34;&#34;&#34;
        return IO(IOTag.RECOVER, (self, handler))

    def map_panic(self, f: Callable[[Exception], Exception]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Transform the exceptions stored if the computation fails on a panic.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return IO(IOTag.MAP_PANIC, (self, f))

    def run(self, context: R, pool_size: int = 1, nighttime=0.01) -&gt; Result[E, A]:
        &#34;&#34;&#34;
        Run the computation.

        Note that a IO is a data structure, no action is performed until you
        call run. You may view an IO value as a function declaration.
        Declaring a function does not execute its body. Only calling the
        function does. Likewise, declaring an IO does not execute its content,
        only running the IO does.

        Note that the return value is a  `Result[E,A]`.
        No exceptions will be raised by run (unless there is a bug), run will
        returns a panic instead!
        &#34;&#34;&#34;
        from raffiot._runtime import SharedState

        return SharedState(pool_size, nighttime).run(self, context)

    def ap(self: IO[R, E, Callable[[X], A]], *arg: IO[R, E, X]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Noting functions from [X1,...,XN] to A: `[X1, ..., Xn] -&gt; A`.

        If self computes a function `f: [X1,...,XN] -&gt; A`
        and arg computes a value `x1: X1`,...,`xn: Xn`
        then self.ap(arg) computes `f(x1,...,xn): A`.
        &#34;&#34;&#34;
        return self.zip(*arg).map(lambda l: l[0](*l[1:]))  # type: ignore

    def attempt(self) -&gt; IO[R, E, Result[E, A]]:
        &#34;&#34;&#34;
        Transform this computation that may fail into a computation
        that never fails but returns a Result[E,A].

        - If `self` successfully computes a, then `self.attempt()` successfully computes `Ok(a)`.
        - If `self` fails on errors e, then `self.attempt()` successfully computes `Errors(e)`.
        - If `self` fails on panic p, then `self.attempt()` successfully computes `Panic(p)`.

        Note that errors and panics stop the computation, unless a catch or
        recover reacts to such failures. But using map, flat_map, flatten and
        ap is sometimes easier than using catch and recover. attempt transforms
        a failed computation into a successful computation returning a failure,
        thus enabling you to use map, flat_map, ... to deal with errors.
        &#34;&#34;&#34;
        return IO(IOTag.ATTEMPT, self)

    def finally_(self, after: Callable[[Result[E, A]], IO[R, E, Any]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        After having computed self, but before returning its result,
        execute the io computation.

        This is extremely useful when you need to perform an action,
        unconditionally, at the end of a computation, without changing
        its result, like releasing a resource.
        &#34;&#34;&#34;
        return self.attempt().flat_map(
            lambda r1: after(r1)
            .attempt()
            .flat_map(lambda r2: from_result(result.sequence(r2, r1)))
        )

    def on_failure(
        self, handler: Callable[[Result[E, Any]], IO[R, E, A]]
    ) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Combined form of catch and recover.
        React to any failure of the computation.
        Do nothing if the computation is successful.

        - The handler will be called on `Errors(e)` if the computation fails with errors e.
        - The handler will be called on `Panic(p)` if the computation fails with panic p.
        - The handler will never be called on `Ok(a)`.
        &#34;&#34;&#34;

        def g(r: Result[E, A]) -&gt; IO[R, E, A]:
            if isinstance(r, Ok):
                return IO(IOTag.PURE, r.success)
            return handler(r)

        return self.attempt().flat_map(g)

    def then_keep(self, *args: IO[R, E, A]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Equivalent to `then(*args) but, on success, the computed value
        is self&#39;s one.

        Used to execute some IO after a successful computation without
        changing its value.
        :param args:
        :return:
        &#34;&#34;&#34;
        return self.flat_map(lambda a: sequence(args).then(pure(a)))

    def __str__(self) -&gt; str:
        if self.__tag == IOTag.PURE:
            return f&#34;Pure({self.__fields})&#34;
        if self.__tag == IOTag.MAP:
            return f&#34;Map({self.__fields})&#34;
        if self.__tag == IOTag.FLATMAP:
            return f&#34;FlatMap({self.__fields})&#34;
        if self.__tag == IOTag.FLATTEN:
            return f&#34;Flatten({self.__fields})&#34;
        if self.__tag == IOTag.SEQUENCE:
            return f&#34;Sequence({self.__fields})&#34;
        if self.__tag == IOTag.ZIP:
            return f&#34;Zip({self.__fields})&#34;
        if self.__tag == IOTag.DEFER:
            return f&#34;Defer({self.__fields})&#34;
        if self.__tag == IOTag.DEFER_IO:
            return f&#34;DeferIO({self.__fields})&#34;
        if self.__tag == IOTag.ATTEMPT:
            return f&#34;Attempt({self.__fields})&#34;
        if self.__tag == IOTag.READ:
            return f&#34;Read({self.__fields})&#34;
        if self.__tag == IOTag.CONTRA_MAP_READ:
            return f&#34;ContraMapRead({self.__fields})&#34;
        if self.__tag == IOTag.ERRORS:
            return f&#34;Errors({self.__fields})&#34;
        if self.__tag == IOTag.CATCH:
            return f&#34;Catch({self.__fields})&#34;
        if self.__tag == IOTag.MAP_ERROR:
            return f&#34;MapError({self.__fields})&#34;
        if self.__tag == IOTag.PANIC:
            return f&#34;Panic({self.__fields})&#34;
        if self.__tag == IOTag.RECOVER:
            return f&#34;Recover({self.__fields})&#34;
        if self.__tag == IOTag.MAP_PANIC:
            return f&#34;MapPanic({self.__fields})&#34;
        if self.__tag == IOTag.YIELD:
            return f&#34;Yield({self.__fields})&#34;
        if self.__tag == IOTag.ASYNC:
            return f&#34;Async({self.__fields})&#34;
        if self.__tag == IOTag.DEFER_READ:
            return f&#34;DeferRead({self.__fields})&#34;
        if self.__tag == IOTag.DEFER_READ_IO:
            return f&#34;DeferReadIO({self.__fields})&#34;
        if self.__tag == IOTag.PARALLEL:
            return f&#34;Parallel({self.__fields})&#34;
        if self.__tag == IOTag.WAIT:
            return f&#34;Wait({self.__fields})&#34;
        if self.__tag == IOTag.SLEEP_UNTIL:
            return f&#34;SleepUntil({self.__fields})&#34;
        if self.__tag == IOTag.REC:
            return f&#34;Rec({self.__fields})&#34;
        if self.__tag == IOTag.ACQUIRE:
            return f&#34;Acquire({self.__fields})&#34;
        if self.__tag == IOTag.RELEASE:
            return f&#34;Release({self.__fields})&#34;
        raise MatchError(f&#34;{self} should be an IO&#34;)

    def __repr__(self):
        return str(self)


def pure(a: A) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    An always successful computation returning a.
    &#34;&#34;&#34;
    return IO(IOTag.PURE, a)


def defer(deferred: Callable[..., A], *args, **kwargs) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Defer a computation.

    The result of the computation is the result of deferred() but
    this call is deferred until the IO is run.

    /!\\ **VERY IMPORTANT** /!\\

    This is the only valid way to execute side effects.
    All side effect should we wrapped by:
        defer(lambda: &lt;your side effecting code&gt;)

    For example, the following code is buggy:

        &gt;&gt;&gt; hello: IO[None, None, None] = pure(print(&#34;Hello World!&#34;))
        &#34;Hello World!&#34; is printed

        &gt;&gt;&gt; hello.run(None)
        Nothing printed

    The correct version is:

        &gt;&gt;&gt; hello: IO[None, None, None] = defer(lambda: print(&#34;Hello World!&#34;))
        Nothing is printed

        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed

        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed again
    &#34;&#34;&#34;
    return IO(IOTag.DEFER, (deferred, args, kwargs))


def defer_io(deferred: Callable[..., IO[R, E, A]], *args, **kwargs) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Make a function that returns an IO, an IO itself.

    This is extremely useful with recursive function that would normally blow
    the stack (raise a stack overflow exceptions). Deferring recursive calls
    eliminates stack overflow.

    For example, the following code blow the stack:

        &gt;&gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;&gt;    return f()
        &gt;&gt;&gt; f().run(None)
        RecursionError: maximum recursion depth exceeded

    But, this one runs forever:

        &gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;    return defer_io(lambda: f())
        &gt;&gt; f().run(None)
    &#34;&#34;&#34;
    return IO(IOTag.DEFER_IO, (deferred, args, kwargs))


read: IO[R, E, R] = IO(IOTag.READ, None)
&#34;&#34;&#34;
Read the context.

To execute a computation `IO[R,E,A]`, you need to call the run method with
some value r of type R: `io.run(r)`. the `read` action returns the value r
given to run.

Please note that the contra_map_read method can transform this value r.
&#34;&#34;&#34;


def error(err: E) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails on the error err.
    &#34;&#34;&#34;
    return IO(IOTag.ERRORS, [err])


def errors(*errs: Union[E, Iterable[E]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails on the errors errs.
    &#34;&#34;&#34;
    if (
        len(errs) == 1
        and isinstance(errs[0], abc.Iterable)
        and not isinstance(errs[0], str)
    ):
        return IO(IOTag.ERRORS, list(errs[0]))
    return IO(IOTag.ERRORS, list(errs))


def panic(
    *exceptions: Union[Exception, Iterable[Exception]], errors: List[E] = None
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails with the panic exceptions.
    &#34;&#34;&#34;
    if len(exceptions) == 1 and isinstance(exceptions[0], abc.Iterable):
        return IO(IOTag.PANIC, (list(exceptions[0]), list(errors) if errors else []))
    return IO(IOTag.PANIC, (list(exceptions), list(errors) if errors else []))


def from_result(r: Result[E, A]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that:
    - success if r is an `Ok`
    - fails with errors e if r is `Errors(e)`
    - fails with panic p if r is `Panic(p)`
    &#34;&#34;&#34;
    if isinstance(r, Ok):
        return pure(r.success)
    if isinstance(r, Errors):
        return errors(r.errors)
    if isinstance(r, Panic):
        return panic(r.exceptions, errors=r.errors)
    return panic(MatchError(f&#34;{r} should be a Result&#34;))


def zip(*l: Union[IO[R, E, A], Iterable[IO[R, E, A]]]) -&gt; IO[R, E, Iterable[A]]:
    &#34;&#34;&#34;
    Transform a list of IO into an IO of list.
    :param l:
    :return:
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.ZIP, list(l[0]))
    return IO(IOTag.ZIP, list(l))


def sequence(*l: Union[IO[R, E, A], Iterable[IO[R, E, A]]]) -&gt; IO[R, E, Iterable[A]]:
    &#34;&#34;&#34;
    Run these ios in sequence
    :param l:
    :return:
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.SEQUENCE, list(l[0]))
    return IO(IOTag.SEQUENCE, list(l))


yield_: IO[R, E, None] = IO(IOTag.YIELD, None)
&#34;&#34;&#34;
IO implement cooperative concurrency. It means an IO has to explicitly
make a break for other concurrent tasks to have a chance to progress.
This is what `yeild_()` does, it forces the IO to make a break, letting
other tasks be run on the thread pool until the IO start progressing again.
:return:
&#34;&#34;&#34;


def async_(
    f: Callable[[R, Callable[[Result[E, A], ...], None]], None], *args, **kwargs
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Perform an Asynchronous call. `f` is a function of the form:

    &gt;&gt;&gt; def f(context: E,
    &gt;&gt;&gt;       callback: Callable[[Result[E,A]], None],
    &gt;&gt;&gt;       *args,
    &gt;&gt;&gt;       **kwargs) -&gt; None:
    &gt;&gt;&gt;     ...

    - `context` is the context of the IO, usually the one passed to `run`
       if not changed by `contra_map_read`.
    - `callback` **MUST ALWAYS BE CALLED EXACTLY ONCE**.
       Until `callback` is called, the IO will be suspended waiting for the
       asynchronous call to complete.
       When `callback` is called, the IO is resumed.
       The value passed to `callback` must be the result of the asynchonous call:

        - `Ok(value)` if the call was successful and returned `value`.
        - `Errors(errors)` if the call failed on errors `errors`.
        - `Panic(exceptions)` if the failed unexpectedly on exceptions `exceptions`.

    For example:

    &gt;&gt;&gt; from raffiot.result import Ok
    &gt;&gt;&gt; from raffiot.io import async_
    &gt;&gt;&gt; def f(context, callback):
    &gt;&gt;&gt;     print(&#34;In the asynchronous call, returning 2.&#34;)
    &gt;&gt;&gt;     callback(Ok(2))
    &gt;&gt;&gt;
    &gt;&gt;&gt; io = async_(f)

    :param f:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.ASYNC, (f, args, kwargs))


def defer_read(deferred: Callable[[R, ...], A], *args, **kwargs) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Like defer, but the function as first argument must be of the form:

    &gt;&gt;&gt; def f(context:R, *args, **kwargs) -&gt; Result[E,A]:

    :param deferred: the function to defer. Its first positional
                     arguments must be the context.
    :param args:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.DEFER_READ, (deferred, args, kwargs))


def defer_read_io(
    deferred: Callable[[R, ...], IO[R, E, A]], *args, **kwargs
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Like defer, but the function as first argument must be of the form:

    &gt;&gt;&gt; def f(context:R, *args, **kwargs) -&gt; IO[R,E,A]:

    :param deferred: the function to defer. Its first positional
                     arguments must be the context.
    :param args:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.DEFER_READ_IO, (deferred, args, kwargs))


def traverse(l: Iterable[A], f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, Iterable[A2]]:
    &#34;&#34;&#34;
    Apply the function `f` to every element of the iterable.
    The resulting IO computes the list of results.

    This function is essentially like map, but f returns IO[R,E,A2] instead of A2.

    :param l: the elements to apply to f
    :param f: the function for each element.
    :return:
    &#34;&#34;&#34;
    return zip([defer_io(f, a) for a in l])


def parallel(*l: Iterable[IO[R, E, A]]) -&gt; IO[E, E, Iterable[Fiber[R, E, A]]]:
    &#34;&#34;&#34;
    Run all these IO in parallel.
    Return the list of fibers, in the same order.

    Each Fiber represent a parallel computation. Call

    &gt;&gt;&gt; wait([fiber1, fiber2, ...])

    to wait until the computations of fiber1, fiber2, etc are done.
    :param l: the list of IO to run in parallel.
    :return: the same list where each IO has been replaced by its Fiber
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.PARALLEL, list(l[0]))
    return IO(IOTag.PARALLEL, list(l))


def wait(*l: Iterable[Fiber[Any, Any, Any]]) -&gt; IO[R, E, List[Result[R, A]]]:
    &#34;&#34;&#34;
    Wait until these Fibers finish. Return the list of Result
    in the same order.
    :param l:
    :return:
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.WAIT, list(l[0]))
    return IO(IOTag.WAIT, list(l))


def zip_par(*others: IO[R, E, X]) -&gt; IO[R, E, List[X]]:
    &#34;&#34;&#34;
    Run these IO in parallel, wait for them to finish, and merge the results.

    :param others:
    :return:
    &#34;&#34;&#34;
    if len(others) == 1 and isinstance(others[0], abc.Iterable):
        args = others[0]
    else:
        args = others
    return (
        parallel(args).flat_map(wait).flat_map(lambda rs: from_result(result.zip(rs)))
    )


def sleep_until(epoch_in_seconds: float) -&gt; IO[R, E, None]:
    &#34;&#34;&#34;
    Pause the computation until the epoch is reached. The epoch
    is the number returned by `time.time`.

    Note that the computation may be awaken any time after the
    specified epoch.
    :param epoch_in_seconds:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.SLEEP_UNTIL, epoch_in_seconds)


def sleep(seconds: float) -&gt; IO[R, E, None]:
    &#34;&#34;&#34;
    Pause the computation for this amount of seconds.

    Note that the computation may paused for longer.
    :param seconds: the minimum number of seconds to sleep (may be longer)
    :return:
    &#34;&#34;&#34;
    return defer(time.time).flat_map(lambda t: sleep_until(t + seconds))


def rec(f: Callable[[IO[R, E, A]], IO[R, E, A]]) -&gt; IO[R, E, A]:
    return IO(IOTag.REC, f)


def safe(f: Callable[..., IO[R, E, A]]) -&gt; Callable[..., IO[R, E, A]]:
    &#34;&#34;&#34;
    Ensures a function retuning an IO never raise any exceptions but returns a
    panic instead.
    &#34;&#34;&#34;

    def wrapper(*args, **kwargs):
        return defer_io(lambda: f(*args, **kwargs))

    return wrapper</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="raffiot.io.read"><code class="name">var <span class="ident">read</span> : <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~R]</code></dt>
<dd>
<div class="desc"><p>Read the context.</p>
<p>To execute a computation <code><a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R,E,A]</code>, you need to call the run method with
some value r of type R: <code>io.run(r)</code>. the <code><a title="raffiot.io.read" href="#raffiot.io.read">read</a></code> action returns the value r
given to run.</p>
<p>Please note that the contra_map_read method can transform this value r.</p></div>
</dd>
<dt id="raffiot.io.yield_"><code class="name">var <span class="ident">yield_</span> : <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, NoneType]</code></dt>
<dd>
<div class="desc"><p>IO implement cooperative concurrency. It means an IO has to explicitly
make a break for other concurrent tasks to have a chance to progress.
This is what <code>yeild_()</code> does, it forces the IO to make a break, letting
other tasks be run on the thread pool until the IO start progressing again.
:return:</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="raffiot.io.async_"><code class="name flex">
<span>def <span class="ident">async_</span></span>(<span>f: Callable[[R, Callable[[Result[E, A], ...], None]], None], *args, **kwargs) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Perform an Asynchronous call. <code>f</code> is a function of the form:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(context: E,
&gt;&gt;&gt;       callback: Callable[[Result[E,A]], None],
&gt;&gt;&gt;       *args,
&gt;&gt;&gt;       **kwargs) -&gt; None:
&gt;&gt;&gt;     ...
</code></pre>
<ul>
<li><code>context</code> is the context of the IO, usually the one passed to <code>run</code>
if not changed by <code>contra_map_read</code>.</li>
<li>
<p><code>callback</code> <strong>MUST ALWAYS BE CALLED EXACTLY ONCE</strong>.
Until <code>callback</code> is called, the IO will be suspended waiting for the
asynchronous call to complete.
When <code>callback</code> is called, the IO is resumed.
The value passed to <code>callback</code> must be the result of the asynchonous call:</p>
<ul>
<li><code>Ok(value)</code> if the call was successful and returned <code>value</code>.</li>
<li><code>Errors(<a title="raffiot.io.errors" href="#raffiot.io.errors">errors()</a>)</code> if the call failed on errors <code><a title="raffiot.io.errors" href="#raffiot.io.errors">errors()</a></code>.</li>
<li><code>Panic(exceptions)</code> if the failed unexpectedly on exceptions <code>exceptions</code>.</li>
</ul>
</li>
</ul>
<p>For example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from raffiot.result import Ok
&gt;&gt;&gt; from raffiot.io import async_
&gt;&gt;&gt; def f(context, callback):
&gt;&gt;&gt;     print(&quot;In the asynchronous call, returning 2.&quot;)
&gt;&gt;&gt;     callback(Ok(2))
&gt;&gt;&gt;
&gt;&gt;&gt; io = async_(f)
</code></pre>
<p>:param f:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def async_(
    f: Callable[[R, Callable[[Result[E, A], ...], None]], None], *args, **kwargs
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Perform an Asynchronous call. `f` is a function of the form:

    &gt;&gt;&gt; def f(context: E,
    &gt;&gt;&gt;       callback: Callable[[Result[E,A]], None],
    &gt;&gt;&gt;       *args,
    &gt;&gt;&gt;       **kwargs) -&gt; None:
    &gt;&gt;&gt;     ...

    - `context` is the context of the IO, usually the one passed to `run`
       if not changed by `contra_map_read`.
    - `callback` **MUST ALWAYS BE CALLED EXACTLY ONCE**.
       Until `callback` is called, the IO will be suspended waiting for the
       asynchronous call to complete.
       When `callback` is called, the IO is resumed.
       The value passed to `callback` must be the result of the asynchonous call:

        - `Ok(value)` if the call was successful and returned `value`.
        - `Errors(errors)` if the call failed on errors `errors`.
        - `Panic(exceptions)` if the failed unexpectedly on exceptions `exceptions`.

    For example:

    &gt;&gt;&gt; from raffiot.result import Ok
    &gt;&gt;&gt; from raffiot.io import async_
    &gt;&gt;&gt; def f(context, callback):
    &gt;&gt;&gt;     print(&#34;In the asynchronous call, returning 2.&#34;)
    &gt;&gt;&gt;     callback(Ok(2))
    &gt;&gt;&gt;
    &gt;&gt;&gt; io = async_(f)

    :param f:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.ASYNC, (f, args, kwargs))</code></pre>
</details>
</dd>
<dt id="raffiot.io.defer"><code class="name flex">
<span>def <span class="ident">defer</span></span>(<span>deferred: Callable[..., A], *args, **kwargs) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Defer a computation.</p>
<p>The result of the computation is the result of deferred() but
this call is deferred until the IO is run.</p>
<p>/!\ <strong>VERY IMPORTANT</strong> /!\</p>
<p>This is the only valid way to execute side effects.
All side effect should we wrapped by:
defer(lambda: <your side effecting code>)</p>
<p>For example, the following code is buggy:</p>
<pre><code>&gt;&gt;&gt; hello: IO[None, None, None] = pure(print("Hello World!"))
"Hello World!" is printed

&gt;&gt;&gt; hello.run(None)
Nothing printed
</code></pre>
<p>The correct version is:</p>
<pre><code>&gt;&gt;&gt; hello: IO[None, None, None] = defer(lambda: print("Hello World!"))
Nothing is printed

&gt;&gt;&gt; hello.run(None)
"Hello World!" is printed

&gt;&gt;&gt; hello.run(None)
"Hello World!" is printed again
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defer(deferred: Callable[..., A], *args, **kwargs) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Defer a computation.

    The result of the computation is the result of deferred() but
    this call is deferred until the IO is run.

    /!\\ **VERY IMPORTANT** /!\\

    This is the only valid way to execute side effects.
    All side effect should we wrapped by:
        defer(lambda: &lt;your side effecting code&gt;)

    For example, the following code is buggy:

        &gt;&gt;&gt; hello: IO[None, None, None] = pure(print(&#34;Hello World!&#34;))
        &#34;Hello World!&#34; is printed

        &gt;&gt;&gt; hello.run(None)
        Nothing printed

    The correct version is:

        &gt;&gt;&gt; hello: IO[None, None, None] = defer(lambda: print(&#34;Hello World!&#34;))
        Nothing is printed

        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed

        &gt;&gt;&gt; hello.run(None)
        &#34;Hello World!&#34; is printed again
    &#34;&#34;&#34;
    return IO(IOTag.DEFER, (deferred, args, kwargs))</code></pre>
</details>
</dd>
<dt id="raffiot.io.defer_io"><code class="name flex">
<span>def <span class="ident">defer_io</span></span>(<span>deferred: Callable[..., <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]], *args, **kwargs) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a function that returns an IO, an IO itself.</p>
<p>This is extremely useful with recursive function that would normally blow
the stack (raise a stack overflow exceptions). Deferring recursive calls
eliminates stack overflow.</p>
<p>For example, the following code blow the stack:</p>
<pre><code>&gt;&gt;&gt; def f() -&gt; IO[None,None,None]:
&gt;&gt;&gt;    return f()
&gt;&gt;&gt; f().run(None)
RecursionError: maximum recursion depth exceeded
</code></pre>
<p>But, this one runs forever:</p>
<pre><code>&gt;&gt; def f() -&gt; IO[None,None,None]:
&gt;&gt;    return defer_io(lambda: f())
&gt;&gt; f().run(None)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defer_io(deferred: Callable[..., IO[R, E, A]], *args, **kwargs) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Make a function that returns an IO, an IO itself.

    This is extremely useful with recursive function that would normally blow
    the stack (raise a stack overflow exceptions). Deferring recursive calls
    eliminates stack overflow.

    For example, the following code blow the stack:

        &gt;&gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;&gt;    return f()
        &gt;&gt;&gt; f().run(None)
        RecursionError: maximum recursion depth exceeded

    But, this one runs forever:

        &gt;&gt; def f() -&gt; IO[None,None,None]:
        &gt;&gt;    return defer_io(lambda: f())
        &gt;&gt; f().run(None)
    &#34;&#34;&#34;
    return IO(IOTag.DEFER_IO, (deferred, args, kwargs))</code></pre>
</details>
</dd>
<dt id="raffiot.io.defer_read"><code class="name flex">
<span>def <span class="ident">defer_read</span></span>(<span>deferred: Callable[[R, ...], A], *args, **kwargs) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Like defer, but the function as first argument must be of the form:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(context:R, *args, **kwargs) -&gt; Result[E,A]:
</code></pre>
<p>:param deferred: the function to defer. Its first positional
arguments must be the context.
:param args:
:param kwargs:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defer_read(deferred: Callable[[R, ...], A], *args, **kwargs) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Like defer, but the function as first argument must be of the form:

    &gt;&gt;&gt; def f(context:R, *args, **kwargs) -&gt; Result[E,A]:

    :param deferred: the function to defer. Its first positional
                     arguments must be the context.
    :param args:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.DEFER_READ, (deferred, args, kwargs))</code></pre>
</details>
</dd>
<dt id="raffiot.io.defer_read_io"><code class="name flex">
<span>def <span class="ident">defer_read_io</span></span>(<span>deferred: Callable[[R, ...], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]], *args, **kwargs) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Like defer, but the function as first argument must be of the form:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(context:R, *args, **kwargs) -&gt; IO[R,E,A]:
</code></pre>
<p>:param deferred: the function to defer. Its first positional
arguments must be the context.
:param args:
:param kwargs:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defer_read_io(
    deferred: Callable[[R, ...], IO[R, E, A]], *args, **kwargs
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Like defer, but the function as first argument must be of the form:

    &gt;&gt;&gt; def f(context:R, *args, **kwargs) -&gt; IO[R,E,A]:

    :param deferred: the function to defer. Its first positional
                     arguments must be the context.
    :param args:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.DEFER_READ_IO, (deferred, args, kwargs))</code></pre>
</details>
</dd>
<dt id="raffiot.io.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>err: E) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Computation that fails on the error err.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(err: E) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails on the error err.
    &#34;&#34;&#34;
    return IO(IOTag.ERRORS, [err])</code></pre>
</details>
</dd>
<dt id="raffiot.io.errors"><code class="name flex">
<span>def <span class="ident">errors</span></span>(<span>*errs: Union[E, Iterable[E]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Computation that fails on the errors errs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errors(*errs: Union[E, Iterable[E]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails on the errors errs.
    &#34;&#34;&#34;
    if (
        len(errs) == 1
        and isinstance(errs[0], abc.Iterable)
        and not isinstance(errs[0], str)
    ):
        return IO(IOTag.ERRORS, list(errs[0]))
    return IO(IOTag.ERRORS, list(errs))</code></pre>
</details>
</dd>
<dt id="raffiot.io.from_result"><code class="name flex">
<span>def <span class="ident">from_result</span></span>(<span>r: Result[E, A]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Computation that:
- success if r is an <code>Ok</code>
- fails with errors e if r is <code>Errors(e)</code>
- fails with panic p if r is <code>Panic(p)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_result(r: Result[E, A]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that:
    - success if r is an `Ok`
    - fails with errors e if r is `Errors(e)`
    - fails with panic p if r is `Panic(p)`
    &#34;&#34;&#34;
    if isinstance(r, Ok):
        return pure(r.success)
    if isinstance(r, Errors):
        return errors(r.errors)
    if isinstance(r, Panic):
        return panic(r.exceptions, errors=r.errors)
    return panic(MatchError(f&#34;{r} should be a Result&#34;))</code></pre>
</details>
</dd>
<dt id="raffiot.io.panic"><code class="name flex">
<span>def <span class="ident">panic</span></span>(<span>*exceptions: Union[Exception, Iterable[Exception]], errors: List[E] = None) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Computation that fails with the panic exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panic(
    *exceptions: Union[Exception, Iterable[Exception]], errors: List[E] = None
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Computation that fails with the panic exceptions.
    &#34;&#34;&#34;
    if len(exceptions) == 1 and isinstance(exceptions[0], abc.Iterable):
        return IO(IOTag.PANIC, (list(exceptions[0]), list(errors) if errors else []))
    return IO(IOTag.PANIC, (list(exceptions), list(errors) if errors else []))</code></pre>
</details>
</dd>
<dt id="raffiot.io.parallel"><code class="name flex">
<span>def <span class="ident">parallel</span></span>(<span>*l: Iterable[<a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~E, ~E, typing.Iterable[<a title="raffiot.io.Fiber" href="#raffiot.io.Fiber">Fiber</a>[~R, ~E, ~A]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Run all these IO in parallel.
Return the list of fibers, in the same order.</p>
<p>Each Fiber represent a parallel computation. Call</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; wait([fiber1, fiber2, ...])
</code></pre>
<p>to wait until the computations of fiber1, fiber2, etc are done.
:param l: the list of IO to run in parallel.
:return: the same list where each IO has been replaced by its Fiber</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parallel(*l: Iterable[IO[R, E, A]]) -&gt; IO[E, E, Iterable[Fiber[R, E, A]]]:
    &#34;&#34;&#34;
    Run all these IO in parallel.
    Return the list of fibers, in the same order.

    Each Fiber represent a parallel computation. Call

    &gt;&gt;&gt; wait([fiber1, fiber2, ...])

    to wait until the computations of fiber1, fiber2, etc are done.
    :param l: the list of IO to run in parallel.
    :return: the same list where each IO has been replaced by its Fiber
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.PARALLEL, list(l[0]))
    return IO(IOTag.PARALLEL, list(l))</code></pre>
</details>
</dd>
<dt id="raffiot.io.pure"><code class="name flex">
<span>def <span class="ident">pure</span></span>(<span>a: A) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>An always successful computation returning a.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pure(a: A) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    An always successful computation returning a.
    &#34;&#34;&#34;
    return IO(IOTag.PURE, a)</code></pre>
</details>
</dd>
<dt id="raffiot.io.rec"><code class="name flex">
<span>def <span class="ident">rec</span></span>(<span>f: Callable[[<a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rec(f: Callable[[IO[R, E, A]], IO[R, E, A]]) -&gt; IO[R, E, A]:
    return IO(IOTag.REC, f)</code></pre>
</details>
</dd>
<dt id="raffiot.io.safe"><code class="name flex">
<span>def <span class="ident">safe</span></span>(<span>f: Callable[..., <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> Callable[..., <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures a function retuning an IO never raise any exceptions but returns a
panic instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe(f: Callable[..., IO[R, E, A]]) -&gt; Callable[..., IO[R, E, A]]:
    &#34;&#34;&#34;
    Ensures a function retuning an IO never raise any exceptions but returns a
    panic instead.
    &#34;&#34;&#34;

    def wrapper(*args, **kwargs):
        return defer_io(lambda: f(*args, **kwargs))

    return wrapper</code></pre>
</details>
</dd>
<dt id="raffiot.io.sequence"><code class="name flex">
<span>def <span class="ident">sequence</span></span>(<span>*l: Union[<a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], Iterable[<a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.Iterable[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Run these ios in sequence
:param l:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sequence(*l: Union[IO[R, E, A], Iterable[IO[R, E, A]]]) -&gt; IO[R, E, Iterable[A]]:
    &#34;&#34;&#34;
    Run these ios in sequence
    :param l:
    :return:
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.SEQUENCE, list(l[0]))
    return IO(IOTag.SEQUENCE, list(l))</code></pre>
</details>
</dd>
<dt id="raffiot.io.sleep"><code class="name flex">
<span>def <span class="ident">sleep</span></span>(<span>seconds: float) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Pause the computation for this amount of seconds.</p>
<p>Note that the computation may paused for longer.
:param seconds: the minimum number of seconds to sleep (may be longer)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sleep(seconds: float) -&gt; IO[R, E, None]:
    &#34;&#34;&#34;
    Pause the computation for this amount of seconds.

    Note that the computation may paused for longer.
    :param seconds: the minimum number of seconds to sleep (may be longer)
    :return:
    &#34;&#34;&#34;
    return defer(time.time).flat_map(lambda t: sleep_until(t + seconds))</code></pre>
</details>
</dd>
<dt id="raffiot.io.sleep_until"><code class="name flex">
<span>def <span class="ident">sleep_until</span></span>(<span>epoch_in_seconds: float) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Pause the computation until the epoch is reached. The epoch
is the number returned by <code>time.time</code>.</p>
<p>Note that the computation may be awaken any time after the
specified epoch.
:param epoch_in_seconds:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sleep_until(epoch_in_seconds: float) -&gt; IO[R, E, None]:
    &#34;&#34;&#34;
    Pause the computation until the epoch is reached. The epoch
    is the number returned by `time.time`.

    Note that the computation may be awaken any time after the
    specified epoch.
    :param epoch_in_seconds:
    :return:
    &#34;&#34;&#34;
    return IO(IOTag.SLEEP_UNTIL, epoch_in_seconds)</code></pre>
</details>
</dd>
<dt id="raffiot.io.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>l: Iterable[A], f: Callable[[A], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A2]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.Iterable[~A2]]</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the function <code>f</code> to every element of the iterable.
The resulting IO computes the list of results.</p>
<p>This function is essentially like map, but f returns IO[R,E,A2] instead of A2.</p>
<p>:param l: the elements to apply to f
:param f: the function for each element.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse(l: Iterable[A], f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, Iterable[A2]]:
    &#34;&#34;&#34;
    Apply the function `f` to every element of the iterable.
    The resulting IO computes the list of results.

    This function is essentially like map, but f returns IO[R,E,A2] instead of A2.

    :param l: the elements to apply to f
    :param f: the function for each element.
    :return:
    &#34;&#34;&#34;
    return zip([defer_io(f, a) for a in l])</code></pre>
</details>
</dd>
<dt id="raffiot.io.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>*l: Iterable[<a title="raffiot.io.Fiber" href="#raffiot.io.Fiber">Fiber</a>[Any, Any, Any]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.List[<a title="raffiot.result.Result" href="result.html#raffiot.result.Result">Result</a>[~R, ~A]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Wait until these Fibers finish. Return the list of Result
in the same order.
:param l:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(*l: Iterable[Fiber[Any, Any, Any]]) -&gt; IO[R, E, List[Result[R, A]]]:
    &#34;&#34;&#34;
    Wait until these Fibers finish. Return the list of Result
    in the same order.
    :param l:
    :return:
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.WAIT, list(l[0]))
    return IO(IOTag.WAIT, list(l))</code></pre>
</details>
</dd>
<dt id="raffiot.io.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>*l: Union[<a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], Iterable[<a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.Iterable[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a list of IO into an IO of list.
:param l:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(*l: Union[IO[R, E, A], Iterable[IO[R, E, A]]]) -&gt; IO[R, E, Iterable[A]]:
    &#34;&#34;&#34;
    Transform a list of IO into an IO of list.
    :param l:
    :return:
    &#34;&#34;&#34;
    if len(l) == 1 and isinstance(l[0], abc.Iterable):
        return IO(IOTag.ZIP, list(l[0]))
    return IO(IOTag.ZIP, list(l))</code></pre>
</details>
</dd>
<dt id="raffiot.io.zip_par"><code class="name flex">
<span>def <span class="ident">zip_par</span></span>(<span>*others: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, X]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.List[~X]]</span>
</code></dt>
<dd>
<div class="desc"><p>Run these IO in parallel, wait for them to finish, and merge the results.</p>
<p>:param others:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip_par(*others: IO[R, E, X]) -&gt; IO[R, E, List[X]]:
    &#34;&#34;&#34;
    Run these IO in parallel, wait for them to finish, and merge the results.

    :param others:
    :return:
    &#34;&#34;&#34;
    if len(others) == 1 and isinstance(others[0], abc.Iterable):
        args = others[0]
    else:
        args = others
    return (
        parallel(args).flat_map(wait).flat_map(lambda rs: from_result(result.zip(rs)))
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="raffiot.io.Fiber"><code class="flex name class">
<span>class <span class="ident">Fiber</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
class Fiber(Generic[R, E, A]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
</dd>
<dt id="raffiot.io.IO"><code class="flex name class">
<span>class <span class="ident">IO</span></span>
<span>(</span><span>_IO__tag, _IO__fields)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a computation that computes a value of type A,
may fail with an errors (expected failure) of type E and have access
anytime to a read-only context of type R.</p>
<p>/!\ <strong>VERY IMPORTANT</strong> /!\</p>
<ol>
<li><strong>DO NEVER SUB-CLASS IO</strong>: it would break the API.</li>
<li><strong>DO NEVER INSTANTIATE an IO DIRECTLY</strong>: use <strong>only</strong> the functions
ands methods in this module.</li>
<li>The IO is <strong>LAZY</strong>:
no code is run until you invoke the run method.</li>
<li>The IO never raises exceptions (unless there is a bug):
it returns panics instead.</li>
<li>The IO is stack-safe, but you need to make sure your own code is too!
use defer and defer_io to avoid stack-overflow.</li>
</ol>
<p>Have a look to the documentation and examples to learn how to use it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@final
class IO(Generic[R, E, A]):
    &#34;&#34;&#34;
    Represent a computation that computes a value of type A,
    may fail with an errors (expected failure) of type E and have access
    anytime to a read-only context of type R.

    /!\\ **VERY IMPORTANT** /!\\

    1. **DO NEVER SUB-CLASS IO**: it would break the API.
    2. **DO NEVER INSTANTIATE an IO DIRECTLY**: use **only** the functions
       ands methods in this module.
    3. The IO is **LAZY**:
        no code is run until you invoke the run method.
    4. The IO never raises exceptions (unless there is a bug):
        it returns panics instead.
    5. The IO is stack-safe, but you need to make sure your own code is too!
        use defer and defer_io to avoid stack-overflow.

    Have a look to the documentation and examples to learn how to use it.
    &#34;&#34;&#34;

    __slots__ = &#34;__tag&#34;, &#34;__fields&#34;

    def __init__(self, __tag, __fields):
        self.__tag = __tag
        self.__fields = __fields

    def map(self, f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Transform the computed value with f if the computation is successful.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return IO(IOTag.MAP, (self, f))

    def flat_map(self, f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) can be used in the second (f).
        &#34;&#34;&#34;
        return IO(IOTag.FLATMAP, (self, f))

    def then(self, *others: IO[R, E, A2]) -&gt; IO[R, E, A2]:
        &#34;&#34;&#34;
        Chain two computations.
        The result of the first one (self) is dropped.
        &#34;&#34;&#34;
        if len(others) == 1 and isinstance(others[0], abc.Iterable):
            return IO(IOTag.SEQUENCE, list((self, *others[0])))
        return IO(IOTag.SEQUENCE, list((self, *others)))

    def zip(self: IO[R, E, A], *others: IO[R, E, X]) -&gt; IO[R, E, Iterable[A]]:
        &#34;&#34;&#34;
        Pack a list of IO (including self) into an IO computing the list
        of all values.

        If one IO fails, the whole computation fails.
        &#34;&#34;&#34;
        if len(others) == 1 and isinstance(others[0], abc.Iterable):
            return IO(IOTag.ZIP, list((self, *others[0])))
        return IO(IOTag.ZIP, list((self, *others)))

    def zip_par(self: IO[R, E, A], *others: IO[R, E, A]) -&gt; IO[R, E, List[A]]:
        &#34;&#34;&#34;
        Pack a list of IO (including self) into an IO computing the list
        of all values in parallel.

        If one IO fails, the whole computation fails.
        &#34;&#34;&#34;
        return zip_par(self, *others)

    def parallel(self: IO[R, E, A], *others: IO[R, E, A]) -&gt; IO[R, E, List[Fiber]]:
        &#34;&#34;&#34;
        Run all these IO (including self) in parallel.
        Return the list of fibers, in the same order.

        Each Fiber represent a parallel computation. Call

        &gt;&gt;&gt; wait([fiber1, fiber2, ...])

        to wait until the computations of fiber1, fiber2, etc are done.
        :param l: the list of IO to run in parallel.
        :return: the same list where each IO has been replaced by its Fiber
        &#34;&#34;&#34;
        if len(others) == 1 and isinstance(others[0], abc.Iterable):
            return IO(IOTag.PARALLEL, list((self, *others[0])))
        return IO(IOTag.PARALLEL, list((self, *others)))

    def flatten(self):
        &#34;&#34;&#34;
        Concatenation function on IO
        &#34;&#34;&#34;
        if self.__tag == 0:
            return self.__fields
        return IO(IOTag.FLATTEN, self)

    # Reader API

    def contra_map_read(self, f: Callable[[R2], R]) -&gt; IO[R2, E, A]:
        &#34;&#34;&#34;
        Transform the context with f.
        Note that f is not from R to R2 but from R2 to R!
        &#34;&#34;&#34;
        return IO(IOTag.CONTRA_MAP_READ, (f, self))

    # Errors API

    def catch(self, handler: Callable[[List[E]], IO[R, E, A]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to errors (the except part of a try-except).

        On errors, call the handler with the errors.
        &#34;&#34;&#34;
        return IO(IOTag.CATCH, (self, handler))

    def map_error(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
        &#34;&#34;&#34;
        Transform the stored errors if the computation fails on an errors.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return IO(IOTag.MAP_ERROR, (self, f))

    # Panic

    def recover(
        self, handler: Callable[[List[Exception], List[E]], IO[R, E, A]]
    ) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        React to panics (the except part of a try-except).

        On panic, call the handler with the exceptions.
        &#34;&#34;&#34;
        return IO(IOTag.RECOVER, (self, handler))

    def map_panic(self, f: Callable[[Exception], Exception]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Transform the exceptions stored if the computation fails on a panic.
        Do nothing otherwise.
        &#34;&#34;&#34;
        return IO(IOTag.MAP_PANIC, (self, f))

    def run(self, context: R, pool_size: int = 1, nighttime=0.01) -&gt; Result[E, A]:
        &#34;&#34;&#34;
        Run the computation.

        Note that a IO is a data structure, no action is performed until you
        call run. You may view an IO value as a function declaration.
        Declaring a function does not execute its body. Only calling the
        function does. Likewise, declaring an IO does not execute its content,
        only running the IO does.

        Note that the return value is a  `Result[E,A]`.
        No exceptions will be raised by run (unless there is a bug), run will
        returns a panic instead!
        &#34;&#34;&#34;
        from raffiot._runtime import SharedState

        return SharedState(pool_size, nighttime).run(self, context)

    def ap(self: IO[R, E, Callable[[X], A]], *arg: IO[R, E, X]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Noting functions from [X1,...,XN] to A: `[X1, ..., Xn] -&gt; A`.

        If self computes a function `f: [X1,...,XN] -&gt; A`
        and arg computes a value `x1: X1`,...,`xn: Xn`
        then self.ap(arg) computes `f(x1,...,xn): A`.
        &#34;&#34;&#34;
        return self.zip(*arg).map(lambda l: l[0](*l[1:]))  # type: ignore

    def attempt(self) -&gt; IO[R, E, Result[E, A]]:
        &#34;&#34;&#34;
        Transform this computation that may fail into a computation
        that never fails but returns a Result[E,A].

        - If `self` successfully computes a, then `self.attempt()` successfully computes `Ok(a)`.
        - If `self` fails on errors e, then `self.attempt()` successfully computes `Errors(e)`.
        - If `self` fails on panic p, then `self.attempt()` successfully computes `Panic(p)`.

        Note that errors and panics stop the computation, unless a catch or
        recover reacts to such failures. But using map, flat_map, flatten and
        ap is sometimes easier than using catch and recover. attempt transforms
        a failed computation into a successful computation returning a failure,
        thus enabling you to use map, flat_map, ... to deal with errors.
        &#34;&#34;&#34;
        return IO(IOTag.ATTEMPT, self)

    def finally_(self, after: Callable[[Result[E, A]], IO[R, E, Any]]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        After having computed self, but before returning its result,
        execute the io computation.

        This is extremely useful when you need to perform an action,
        unconditionally, at the end of a computation, without changing
        its result, like releasing a resource.
        &#34;&#34;&#34;
        return self.attempt().flat_map(
            lambda r1: after(r1)
            .attempt()
            .flat_map(lambda r2: from_result(result.sequence(r2, r1)))
        )

    def on_failure(
        self, handler: Callable[[Result[E, Any]], IO[R, E, A]]
    ) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Combined form of catch and recover.
        React to any failure of the computation.
        Do nothing if the computation is successful.

        - The handler will be called on `Errors(e)` if the computation fails with errors e.
        - The handler will be called on `Panic(p)` if the computation fails with panic p.
        - The handler will never be called on `Ok(a)`.
        &#34;&#34;&#34;

        def g(r: Result[E, A]) -&gt; IO[R, E, A]:
            if isinstance(r, Ok):
                return IO(IOTag.PURE, r.success)
            return handler(r)

        return self.attempt().flat_map(g)

    def then_keep(self, *args: IO[R, E, A]) -&gt; IO[R, E, A]:
        &#34;&#34;&#34;
        Equivalent to `then(*args) but, on success, the computed value
        is self&#39;s one.

        Used to execute some IO after a successful computation without
        changing its value.
        :param args:
        :return:
        &#34;&#34;&#34;
        return self.flat_map(lambda a: sequence(args).then(pure(a)))

    def __str__(self) -&gt; str:
        if self.__tag == IOTag.PURE:
            return f&#34;Pure({self.__fields})&#34;
        if self.__tag == IOTag.MAP:
            return f&#34;Map({self.__fields})&#34;
        if self.__tag == IOTag.FLATMAP:
            return f&#34;FlatMap({self.__fields})&#34;
        if self.__tag == IOTag.FLATTEN:
            return f&#34;Flatten({self.__fields})&#34;
        if self.__tag == IOTag.SEQUENCE:
            return f&#34;Sequence({self.__fields})&#34;
        if self.__tag == IOTag.ZIP:
            return f&#34;Zip({self.__fields})&#34;
        if self.__tag == IOTag.DEFER:
            return f&#34;Defer({self.__fields})&#34;
        if self.__tag == IOTag.DEFER_IO:
            return f&#34;DeferIO({self.__fields})&#34;
        if self.__tag == IOTag.ATTEMPT:
            return f&#34;Attempt({self.__fields})&#34;
        if self.__tag == IOTag.READ:
            return f&#34;Read({self.__fields})&#34;
        if self.__tag == IOTag.CONTRA_MAP_READ:
            return f&#34;ContraMapRead({self.__fields})&#34;
        if self.__tag == IOTag.ERRORS:
            return f&#34;Errors({self.__fields})&#34;
        if self.__tag == IOTag.CATCH:
            return f&#34;Catch({self.__fields})&#34;
        if self.__tag == IOTag.MAP_ERROR:
            return f&#34;MapError({self.__fields})&#34;
        if self.__tag == IOTag.PANIC:
            return f&#34;Panic({self.__fields})&#34;
        if self.__tag == IOTag.RECOVER:
            return f&#34;Recover({self.__fields})&#34;
        if self.__tag == IOTag.MAP_PANIC:
            return f&#34;MapPanic({self.__fields})&#34;
        if self.__tag == IOTag.YIELD:
            return f&#34;Yield({self.__fields})&#34;
        if self.__tag == IOTag.ASYNC:
            return f&#34;Async({self.__fields})&#34;
        if self.__tag == IOTag.DEFER_READ:
            return f&#34;DeferRead({self.__fields})&#34;
        if self.__tag == IOTag.DEFER_READ_IO:
            return f&#34;DeferReadIO({self.__fields})&#34;
        if self.__tag == IOTag.PARALLEL:
            return f&#34;Parallel({self.__fields})&#34;
        if self.__tag == IOTag.WAIT:
            return f&#34;Wait({self.__fields})&#34;
        if self.__tag == IOTag.SLEEP_UNTIL:
            return f&#34;SleepUntil({self.__fields})&#34;
        if self.__tag == IOTag.REC:
            return f&#34;Rec({self.__fields})&#34;
        if self.__tag == IOTag.ACQUIRE:
            return f&#34;Acquire({self.__fields})&#34;
        if self.__tag == IOTag.RELEASE:
            return f&#34;Release({self.__fields})&#34;
        raise MatchError(f&#34;{self} should be an IO&#34;)

    def __repr__(self):
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="raffiot.io.IO.ap"><code class="name flex">
<span>def <span class="ident">ap</span></span>(<span>self: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, Callable[[X], A]], *arg: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, X]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Noting functions from [X1,&hellip;,XN] to A: <code>[X1, ..., Xn] -&gt; A</code>.</p>
<p>If self computes a function <code>f: [X1,...,XN] -&gt; A</code>
and arg computes a value <code>x1: X1</code>,&hellip;,<code>xn: Xn</code>
then self.ap(arg) computes <code>f(x1,...,xn): A</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ap(self: IO[R, E, Callable[[X], A]], *arg: IO[R, E, X]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Noting functions from [X1,...,XN] to A: `[X1, ..., Xn] -&gt; A`.

    If self computes a function `f: [X1,...,XN] -&gt; A`
    and arg computes a value `x1: X1`,...,`xn: Xn`
    then self.ap(arg) computes `f(x1,...,xn): A`.
    &#34;&#34;&#34;
    return self.zip(*arg).map(lambda l: l[0](*l[1:]))  # type: ignore</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.attempt"><code class="name flex">
<span>def <span class="ident">attempt</span></span>(<span>self) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, <a title="raffiot.result.Result" href="result.html#raffiot.result.Result">Result</a>[~E, ~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform this computation that may fail into a computation
that never fails but returns a Result[E,A].</p>
<ul>
<li>If <code>self</code> successfully computes a, then <code>self.attempt()</code> successfully computes <code>Ok(a)</code>.</li>
<li>If <code>self</code> fails on errors e, then <code>self.attempt()</code> successfully computes <code>Errors(e)</code>.</li>
<li>If <code>self</code> fails on panic p, then <code>self.attempt()</code> successfully computes <code>Panic(p)</code>.</li>
</ul>
<p>Note that errors and panics stop the computation, unless a catch or
recover reacts to such failures. But using map, flat_map, flatten and
ap is sometimes easier than using catch and recover. attempt transforms
a failed computation into a successful computation returning a failure,
thus enabling you to use map, flat_map, &hellip; to deal with errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attempt(self) -&gt; IO[R, E, Result[E, A]]:
    &#34;&#34;&#34;
    Transform this computation that may fail into a computation
    that never fails but returns a Result[E,A].

    - If `self` successfully computes a, then `self.attempt()` successfully computes `Ok(a)`.
    - If `self` fails on errors e, then `self.attempt()` successfully computes `Errors(e)`.
    - If `self` fails on panic p, then `self.attempt()` successfully computes `Panic(p)`.

    Note that errors and panics stop the computation, unless a catch or
    recover reacts to such failures. But using map, flat_map, flatten and
    ap is sometimes easier than using catch and recover. attempt transforms
    a failed computation into a successful computation returning a failure,
    thus enabling you to use map, flat_map, ... to deal with errors.
    &#34;&#34;&#34;
    return IO(IOTag.ATTEMPT, self)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.catch"><code class="name flex">
<span>def <span class="ident">catch</span></span>(<span>self, handler: Callable[[List[E]], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>React to errors (the except part of a try-except).</p>
<p>On errors, call the handler with the errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def catch(self, handler: Callable[[List[E]], IO[R, E, A]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    React to errors (the except part of a try-except).

    On errors, call the handler with the errors.
    &#34;&#34;&#34;
    return IO(IOTag.CATCH, (self, handler))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.contra_map_read"><code class="name flex">
<span>def <span class="ident">contra_map_read</span></span>(<span>self, f: Callable[[R2], R]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R2, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the context with f.
Note that f is not from R to R2 but from R2 to R!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contra_map_read(self, f: Callable[[R2], R]) -&gt; IO[R2, E, A]:
    &#34;&#34;&#34;
    Transform the context with f.
    Note that f is not from R to R2 but from R2 to R!
    &#34;&#34;&#34;
    return IO(IOTag.CONTRA_MAP_READ, (f, self))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.finally_"><code class="name flex">
<span>def <span class="ident">finally_</span></span>(<span>self, after: Callable[[Result[E, A]], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, Any]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>After having computed self, but before returning its result,
execute the io computation.</p>
<p>This is extremely useful when you need to perform an action,
unconditionally, at the end of a computation, without changing
its result, like releasing a resource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finally_(self, after: Callable[[Result[E, A]], IO[R, E, Any]]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    After having computed self, but before returning its result,
    execute the io computation.

    This is extremely useful when you need to perform an action,
    unconditionally, at the end of a computation, without changing
    its result, like releasing a resource.
    &#34;&#34;&#34;
    return self.attempt().flat_map(
        lambda r1: after(r1)
        .attempt()
        .flat_map(lambda r2: from_result(result.sequence(r2, r1)))
    )</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.flat_map"><code class="name flex">
<span>def <span class="ident">flat_map</span></span>(<span>self, f: Callable[[A], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A2]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Chain two computations.
The result of the first one (self) can be used in the second (f).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flat_map(self, f: Callable[[A], IO[R, E, A2]]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Chain two computations.
    The result of the first one (self) can be used in the second (f).
    &#34;&#34;&#34;
    return IO(IOTag.FLATMAP, (self, f))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenation function on IO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(self):
    &#34;&#34;&#34;
    Concatenation function on IO
    &#34;&#34;&#34;
    if self.__tag == 0:
        return self.__fields
    return IO(IOTag.FLATTEN, self)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f: Callable[[A], A2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the computed value with f if the computation is successful.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f: Callable[[A], A2]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Transform the computed value with f if the computation is successful.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return IO(IOTag.MAP, (self, f))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.map_error"><code class="name flex">
<span>def <span class="ident">map_error</span></span>(<span>self, f: Callable[[E], E2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E2, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the stored errors if the computation fails on an errors.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_error(self, f: Callable[[E], E2]) -&gt; IO[R, E2, A]:
    &#34;&#34;&#34;
    Transform the stored errors if the computation fails on an errors.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return IO(IOTag.MAP_ERROR, (self, f))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.map_panic"><code class="name flex">
<span>def <span class="ident">map_panic</span></span>(<span>self, f: Callable[[Exception], Exception]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the exceptions stored if the computation fails on a panic.
Do nothing otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_panic(self, f: Callable[[Exception], Exception]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Transform the exceptions stored if the computation fails on a panic.
    Do nothing otherwise.
    &#34;&#34;&#34;
    return IO(IOTag.MAP_PANIC, (self, f))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.on_failure"><code class="name flex">
<span>def <span class="ident">on_failure</span></span>(<span>self, handler: Callable[[Result[E, Any]], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Combined form of catch and recover.
React to any failure of the computation.
Do nothing if the computation is successful.</p>
<ul>
<li>The handler will be called on <code>Errors(e)</code> if the computation fails with errors e.</li>
<li>The handler will be called on <code>Panic(p)</code> if the computation fails with panic p.</li>
<li>The handler will never be called on <code>Ok(a)</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_failure(
    self, handler: Callable[[Result[E, Any]], IO[R, E, A]]
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Combined form of catch and recover.
    React to any failure of the computation.
    Do nothing if the computation is successful.

    - The handler will be called on `Errors(e)` if the computation fails with errors e.
    - The handler will be called on `Panic(p)` if the computation fails with panic p.
    - The handler will never be called on `Ok(a)`.
    &#34;&#34;&#34;

    def g(r: Result[E, A]) -&gt; IO[R, E, A]:
        if isinstance(r, Ok):
            return IO(IOTag.PURE, r.success)
        return handler(r)

    return self.attempt().flat_map(g)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.parallel"><code class="name flex">
<span>def <span class="ident">parallel</span></span>(<span>self: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], *others: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.List[<a title="raffiot.io.Fiber" href="#raffiot.io.Fiber">Fiber</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Run all these IO (including self) in parallel.
Return the list of fibers, in the same order.</p>
<p>Each Fiber represent a parallel computation. Call</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; wait([fiber1, fiber2, ...])
</code></pre>
<p>to wait until the computations of fiber1, fiber2, etc are done.
:param l: the list of IO to run in parallel.
:return: the same list where each IO has been replaced by its Fiber</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parallel(self: IO[R, E, A], *others: IO[R, E, A]) -&gt; IO[R, E, List[Fiber]]:
    &#34;&#34;&#34;
    Run all these IO (including self) in parallel.
    Return the list of fibers, in the same order.

    Each Fiber represent a parallel computation. Call

    &gt;&gt;&gt; wait([fiber1, fiber2, ...])

    to wait until the computations of fiber1, fiber2, etc are done.
    :param l: the list of IO to run in parallel.
    :return: the same list where each IO has been replaced by its Fiber
    &#34;&#34;&#34;
    if len(others) == 1 and isinstance(others[0], abc.Iterable):
        return IO(IOTag.PARALLEL, list((self, *others[0])))
    return IO(IOTag.PARALLEL, list((self, *others)))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.recover"><code class="name flex">
<span>def <span class="ident">recover</span></span>(<span>self, handler: Callable[[List[Exception], List[E]], <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>React to panics (the except part of a try-except).</p>
<p>On panic, call the handler with the exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recover(
    self, handler: Callable[[List[Exception], List[E]], IO[R, E, A]]
) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    React to panics (the except part of a try-except).

    On panic, call the handler with the exceptions.
    &#34;&#34;&#34;
    return IO(IOTag.RECOVER, (self, handler))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, context: R, pool_size: int = 1, nighttime=0.01) ‑> <a title="raffiot.result.Result" href="result.html#raffiot.result.Result">Result</a>[~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Run the computation.</p>
<p>Note that a IO is a data structure, no action is performed until you
call run. You may view an IO value as a function declaration.
Declaring a function does not execute its body. Only calling the
function does. Likewise, declaring an IO does not execute its content,
only running the IO does.</p>
<p>Note that the return value is a
<code>Result[E,A]</code>.
No exceptions will be raised by run (unless there is a bug), run will
returns a panic instead!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, context: R, pool_size: int = 1, nighttime=0.01) -&gt; Result[E, A]:
    &#34;&#34;&#34;
    Run the computation.

    Note that a IO is a data structure, no action is performed until you
    call run. You may view an IO value as a function declaration.
    Declaring a function does not execute its body. Only calling the
    function does. Likewise, declaring an IO does not execute its content,
    only running the IO does.

    Note that the return value is a  `Result[E,A]`.
    No exceptions will be raised by run (unless there is a bug), run will
    returns a panic instead!
    &#34;&#34;&#34;
    from raffiot._runtime import SharedState

    return SharedState(pool_size, nighttime).run(self, context)</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.then"><code class="name flex">
<span>def <span class="ident">then</span></span>(<span>self, *others: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A2]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A2]</span>
</code></dt>
<dd>
<div class="desc"><p>Chain two computations.
The result of the first one (self) is dropped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def then(self, *others: IO[R, E, A2]) -&gt; IO[R, E, A2]:
    &#34;&#34;&#34;
    Chain two computations.
    The result of the first one (self) is dropped.
    &#34;&#34;&#34;
    if len(others) == 1 and isinstance(others[0], abc.Iterable):
        return IO(IOTag.SEQUENCE, list((self, *others[0])))
    return IO(IOTag.SEQUENCE, list((self, *others)))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.then_keep"><code class="name flex">
<span>def <span class="ident">then_keep</span></span>(<span>self, *args: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, ~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Equivalent to `then(*args) but, on success, the computed value
is self's one.</p>
<p>Used to execute some IO after a successful computation without
changing its value.
:param args:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def then_keep(self, *args: IO[R, E, A]) -&gt; IO[R, E, A]:
    &#34;&#34;&#34;
    Equivalent to `then(*args) but, on success, the computed value
    is self&#39;s one.

    Used to execute some IO after a successful computation without
    changing its value.
    :param args:
    :return:
    &#34;&#34;&#34;
    return self.flat_map(lambda a: sequence(args).then(pure(a)))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], *others: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, X]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.Iterable[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Pack a list of IO (including self) into an IO computing the list
of all values.</p>
<p>If one IO fails, the whole computation fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self: IO[R, E, A], *others: IO[R, E, X]) -&gt; IO[R, E, Iterable[A]]:
    &#34;&#34;&#34;
    Pack a list of IO (including self) into an IO computing the list
    of all values.

    If one IO fails, the whole computation fails.
    &#34;&#34;&#34;
    if len(others) == 1 and isinstance(others[0], abc.Iterable):
        return IO(IOTag.ZIP, list((self, *others[0])))
    return IO(IOTag.ZIP, list((self, *others)))</code></pre>
</details>
</dd>
<dt id="raffiot.io.IO.zip_par"><code class="name flex">
<span>def <span class="ident">zip_par</span></span>(<span>self: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A], *others: <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[R, E, A]) ‑> <a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a>[~R, ~E, typing.List[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Pack a list of IO (including self) into an IO computing the list
of all values in parallel.</p>
<p>If one IO fails, the whole computation fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip_par(self: IO[R, E, A], *others: IO[R, E, A]) -&gt; IO[R, E, List[A]]:
    &#34;&#34;&#34;
    Pack a list of IO (including self) into an IO computing the list
    of all values in parallel.

    If one IO fails, the whole computation fails.
    &#34;&#34;&#34;
    return zip_par(self, *others)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="raffiot" href="index.html">raffiot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="raffiot.io.read" href="#raffiot.io.read">read</a></code></li>
<li><code><a title="raffiot.io.yield_" href="#raffiot.io.yield_">yield_</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="raffiot.io.async_" href="#raffiot.io.async_">async_</a></code></li>
<li><code><a title="raffiot.io.defer" href="#raffiot.io.defer">defer</a></code></li>
<li><code><a title="raffiot.io.defer_io" href="#raffiot.io.defer_io">defer_io</a></code></li>
<li><code><a title="raffiot.io.defer_read" href="#raffiot.io.defer_read">defer_read</a></code></li>
<li><code><a title="raffiot.io.defer_read_io" href="#raffiot.io.defer_read_io">defer_read_io</a></code></li>
<li><code><a title="raffiot.io.error" href="#raffiot.io.error">error</a></code></li>
<li><code><a title="raffiot.io.errors" href="#raffiot.io.errors">errors</a></code></li>
<li><code><a title="raffiot.io.from_result" href="#raffiot.io.from_result">from_result</a></code></li>
<li><code><a title="raffiot.io.panic" href="#raffiot.io.panic">panic</a></code></li>
<li><code><a title="raffiot.io.parallel" href="#raffiot.io.parallel">parallel</a></code></li>
<li><code><a title="raffiot.io.pure" href="#raffiot.io.pure">pure</a></code></li>
<li><code><a title="raffiot.io.rec" href="#raffiot.io.rec">rec</a></code></li>
<li><code><a title="raffiot.io.safe" href="#raffiot.io.safe">safe</a></code></li>
<li><code><a title="raffiot.io.sequence" href="#raffiot.io.sequence">sequence</a></code></li>
<li><code><a title="raffiot.io.sleep" href="#raffiot.io.sleep">sleep</a></code></li>
<li><code><a title="raffiot.io.sleep_until" href="#raffiot.io.sleep_until">sleep_until</a></code></li>
<li><code><a title="raffiot.io.traverse" href="#raffiot.io.traverse">traverse</a></code></li>
<li><code><a title="raffiot.io.wait" href="#raffiot.io.wait">wait</a></code></li>
<li><code><a title="raffiot.io.zip" href="#raffiot.io.zip">zip</a></code></li>
<li><code><a title="raffiot.io.zip_par" href="#raffiot.io.zip_par">zip_par</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="raffiot.io.Fiber" href="#raffiot.io.Fiber">Fiber</a></code></h4>
</li>
<li>
<h4><code><a title="raffiot.io.IO" href="#raffiot.io.IO">IO</a></code></h4>
<ul class="two-column">
<li><code><a title="raffiot.io.IO.ap" href="#raffiot.io.IO.ap">ap</a></code></li>
<li><code><a title="raffiot.io.IO.attempt" href="#raffiot.io.IO.attempt">attempt</a></code></li>
<li><code><a title="raffiot.io.IO.catch" href="#raffiot.io.IO.catch">catch</a></code></li>
<li><code><a title="raffiot.io.IO.contra_map_read" href="#raffiot.io.IO.contra_map_read">contra_map_read</a></code></li>
<li><code><a title="raffiot.io.IO.finally_" href="#raffiot.io.IO.finally_">finally_</a></code></li>
<li><code><a title="raffiot.io.IO.flat_map" href="#raffiot.io.IO.flat_map">flat_map</a></code></li>
<li><code><a title="raffiot.io.IO.flatten" href="#raffiot.io.IO.flatten">flatten</a></code></li>
<li><code><a title="raffiot.io.IO.map" href="#raffiot.io.IO.map">map</a></code></li>
<li><code><a title="raffiot.io.IO.map_error" href="#raffiot.io.IO.map_error">map_error</a></code></li>
<li><code><a title="raffiot.io.IO.map_panic" href="#raffiot.io.IO.map_panic">map_panic</a></code></li>
<li><code><a title="raffiot.io.IO.on_failure" href="#raffiot.io.IO.on_failure">on_failure</a></code></li>
<li><code><a title="raffiot.io.IO.parallel" href="#raffiot.io.IO.parallel">parallel</a></code></li>
<li><code><a title="raffiot.io.IO.recover" href="#raffiot.io.IO.recover">recover</a></code></li>
<li><code><a title="raffiot.io.IO.run" href="#raffiot.io.IO.run">run</a></code></li>
<li><code><a title="raffiot.io.IO.then" href="#raffiot.io.IO.then">then</a></code></li>
<li><code><a title="raffiot.io.IO.then_keep" href="#raffiot.io.IO.then_keep">then_keep</a></code></li>
<li><code><a title="raffiot.io.IO.zip" href="#raffiot.io.IO.zip">zip</a></code></li>
<li><code><a title="raffiot.io.IO.zip_par" href="#raffiot.io.IO.zip_par">zip_par</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>